<!--

    Licensed to Jasig under one or more contributor license
    agreements. See the NOTICE file distributed with this work
    for additional information regarding copyright ownership.
    Jasig licenses this file to you under the Apache License,
    Version 2.0 (the "License"); you may not use this file
    except in compliance with the License. You may obtain a
    copy of the License at:

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing,
    software distributed under the License is distributed on
    an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, either express or implied. See the License for the
    specific language governing permissions and limitations
    under the License.

-->

<!--
 | NOTICE:  This file represents a contractual API that is leveraged by more 
 | than one caller.  Please do not refactor this file in a way that changes 
 | the number or nature of arguments expected.
 |
 | These are:
 |   - ${Attributes.NODE}=XML Element that defines the entity to import
 |   - ${PORTAL_CONTEXT}=uPortal's Spring ApplicationContext
 |   - ${SqlAttributes.DATA_SOURCE}=the DataSource for the PortalDb
 |   - ${SqlAttributes.TRANSACTION_MANAGER}=PlatformTransactionManager in use
 |
 | To debug, change log.debug to log.error (script classname is dynamic; e.g. Script1, Script 13, etc.)
 +-->
<!-- Group membership processing is done in two steps in an initdb.  All groups are created in one pass.
     In a second pass, the child elements are processed because they can reference the now-created groups. -->
<choose>
    <when test="${jexl(IMPORT_ACTION.equals('GROUP'))}">
        <!-- The group creation/update is done with sql as opposed to GroupService.newGroup() and group.update() like
             GroupAdministrationHelper because there are special groups that have a system-assigned id and there is
             not much value in modifying GroupService group creation methods to accept creating a group with
             a specific id. The only downside to using sql for creating or editing the group as opposed to
             GroupService and group.update() is that you can change the creator or description and the cached
             values may not be updated.  Not a big deal.-->
        <with-attribute key="ENTITY_TYPE" value="${valueOf(entity-type)}">
        <with>
            <attribute key="CREATOR">${valueOf(creator)}</attribute>
            <attribute key="DESCRIPTION">${valueOf(description)}</attribute>
            <attribute key="ENTITY_TYPE_NAME">${groovy("org.jasig.portal.channel.IChannelDefinition".equals(ENTITY_TYPE) ? "org.jasig.portal.portlet.om.IPortletDefinition" : ENTITY_TYPE)}</attribute>
            <attribute key="GROUP_NAME">${valueOf(name)}</attribute>
            <subtasks>
                <with-attribute key="ENTITY_TYPE_ID" value="${crn(lookup-entity_type_id.crn)}">
                    <sql-transaction>
                        <sql-upsert>
                            <update-statement>
                                UPDATE up_group
                                SET creator_id = ?, description = ?
                                WHERE entity_type_id = ? AND group_name = ?
                            </update-statement>
                            <insert-statement>
                                INSERT INTO up_group(creator_id, description, entity_type_id, group_name, group_id)
                                VALUES(?, ?, ?, ?, ?)
                            </insert-statement>

                            <update-parameter value="${CREATOR}"/>
                            <update-parameter value="${DESCRIPTION}"/>
                            <update-parameter value="${ENTITY_TYPE_ID}"/>
                            <update-parameter value="${GROUP_NAME}"/>

                            <insert-parameter value="${CREATOR}"/>
                            <insert-parameter value="${DESCRIPTION}"/>
                            <insert-parameter value="${ENTITY_TYPE_ID}"/>
                            <insert-parameter value="${GROUP_NAME}"/>
                            <insert-parameter value="${crn(generate-group-id.crn)}"/>
                        </sql-upsert>
                    </sql-transaction>
                </with-attribute>
            </subtasks>
        </with>
        </with-attribute>
    </when>
    <when test="${jexl(IMPORT_ACTION.equals('MEMBERS'))}">
        <with>
            <attribute key="GROUP_NAME">${valueOf(name)}</attribute>
            <attribute key="ENTITY_TYPE">${valueOf(entity-type)}</attribute>
            <attribute key="MEMBER_COUNT">${valueOf(count(children/*))}</attribute>
            <subtasks>
                <!-- If there are no members, don't delete existing members -->
                <if test="${jexl(MEMBER_COUNT > 0)}">
                    <!-- Use methods similar to GroupAdministrationHelper to reflect updates through the GroupServices so caches
                         get cleared and replicated to other nodes. -->
                    <with>
                        <attribute key="group">${groovy(org.jasig.portal.services.GroupService.findGroup(org.jasig.portal.services.GroupService.searchForGroups(GROUP_NAME, org.jasig.portal.groups.IGroupConstants.IS, Class.forName(ENTITY_TYPE))[0].key))}</attribute>
                        <subtasks>
                            <groovy>
                                <script>
                                    import org.slf4j.LoggerFactory
                                    def log = LoggerFactory.getLogger(this.getClass());
                                    log.debug("Removing members from group $group")
                                    group.getMembers().each() {group.removeMember(it)}
                                </script>
                            </groovy>
                            <node-iterator xpath="children/*">
                                <groovy>
                                    <script>
                                        import org.jasig.portal.groups.IEntityGroup
                                        import org.jasig.portal.groups.IGroupConstants
                                        import org.jasig.portal.groups.IGroupMember
                                        import org.jasig.portal.io.GetMemberIsGroupPhrase
                                        import org.jasig.portal.io.GetMemberKeyPhrase
                                        import org.jasig.portal.io.GetMemberServicePhrase
                                        import org.jasig.portal.services.GroupService
                                        import org.slf4j.LoggerFactory

                                        def log = LoggerFactory.getLogger(this.getClass())
                                        String groupService = GetMemberServicePhrase.getPhrase(Attributes.NODE.getName(), Attributes.NODE.getText())
                                        String memberId = GetMemberKeyPhrase.getPhrase(Attributes.NODE.getName(), Attributes.NODE.getText())
                                        log.debug("Found service=$groupService, memberId=$memberId")

                                        if (GetMemberIsGroupPhrase.phraseIsGroup(Attributes.NODE.getName())) {
                                            String key = groupService + '.' + memberId
                                            log.debug("Created key $key")
                                            IEntityGroup member = GroupService.findGroup(key)
                                            log.debug("Adding group $member")
                                            group.addMember(member)
                                        } else {
                                            IGroupMember member = GroupService.getGroupMember(memberId, Class.forName(ENTITY_TYPE))
                                            log.debug("Adding entity $member")
                                            group.addMember(member)
                                        }
                                    </script>
                                </groovy>
                            </node-iterator>
                            <groovy>
                                <script>
                                    group.updateMembers()
                                </script>
                            </groovy>
                        </subtasks>
                    </with>
                </if>
            </subtasks>
        </with>
    </when>
</choose>