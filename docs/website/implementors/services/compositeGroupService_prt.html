<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
  <HEAD>
    <META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=utf-8">
    <!-- TO CHANGE: change the document title -->
    <TITLE>
      Composite Group Service
    </TITLE>
    <META NAME="GENERATOR" CONTENT="OpenOffice.org 1.0.1  (Linux)">
    <META NAME="AUTHOR" CONTENT="Don Fracapane">
    <META NAME="CREATED" CONTENT="20021210;14440000">
    <META NAME="CHANGEDBY" CONTENT="Don Fracapane">
    <META NAME="CHANGED" CONTENT="20021220;15440000">
  </HEAD>
  <BODY LANG="en-US" TEXT="#000000">

<!-- start cut this section to put into jasig table cell format -->
      <div align="center">                                              
      <h2>Developers and Deployers Guide to the Composite Group Service</h2>
      </div>
      <br>

      <h4>Contents</h4>
     
      <blockquote><a href="#Introduction">Introduction</a><br>
                  <a href="#Whats_In_This_Document">What's In This Document?</a><br>
                  <a href="#What_Does_it_Contain">Goals and Rationale of
the   Composite  Service</a><br>
                  <a href="#The_Service_Design">The Service Design</a><br>
                  <a href="#Groups_Keys_and_Service_Names">Groups, Keys and 
 Service   Names</a><br>
                  <a href="#Assembling_the_Composite">Assembling the Composite</a><br>
                  <a href="#Configuring_the_Composite">Configuring the Composite</a><br>
                  <a href="#The_LDAP_Group_Store">The LDAP Group Store</a><br>
              <a href="#Next_Steps">Next Steps</a><br>
                </blockquote>
                                                                        
       
      <h4><a name="Introduction"></a>Introduction</h4>
                                                                       
      <p>Early in the uPortal project, it became clear that some mechanism 
was needed for <i>grouping</i> portal users, chiefly for the purpose of authorization. 
&nbsp;The <code>org.jasig.portal.groups</code> package evolved in response. 
&nbsp;It defines an api for managing groups of portal <i>entities</i> such 
as IPersons and IChannels.&nbsp; The groups framework does not actually 
operate on IPersons or IChannels; it manipulates stub objects whose keys
and types point to the underlying entities.&nbsp; The stubs are implementations
of <code>org.jasig.portal.groups.IEntity</code>, and their only concern
is their group memberships.&nbsp; A stub knows nothing about its underlying
entity except its key and type.&nbsp; The groups it belongs to are implementations 
of <code>org.jasig.portal.groups.IEntityGroup</code>.&nbsp; 
The groups are recursive (groups can contain other groups) and homogeneous 
(their <code>IEntities</code> have only one type of underlying entity.) &nbsp;</p>

      <p>Prior to version 2.1, groups came from a group service with 
a single store.&nbsp; With the release of version 2.1, uPortal ships with
a composite group service made up of multiple component services, each 
with its own group store.&nbsp; This document describes the composite
design and  explains how  to configure a composite group service for your
environment.  &nbsp;It is principally aimed at implementors and developers,
but it&nbsp;may also be helpful to planners evaluating uPortal's support 
for native sources of group information.</p>
                                                                       
      <p>Although it is hidden from clients, the design of the composite
group service is significant to the uPortal <i>Implementor</i> who must
configure the composite service and to the uPortal <i>Developer </i>who may
have to write a custom group service or group store to adapt a native source
of group information to the portal groups design.&nbsp; The implementor
assigns the appropriate role to each source of group information and represents
the composition in an xml configuration file, while the group service or
store developer must implement the various group api's.&nbsp;&nbsp;</p>
                                                                       
      <h4><a name="Whats_In_This_Document"></a>What's In This Document?</h4>
                                                                       
      <p>    The rest of the document is organized as follows:&nbsp; the
first section   (<a href="#Goals_and_Rationale_of_the_Composite">Goals and
Rationale of the Composite Service</a>) sets out the argument for a composite
service.&nbsp;    The next section (<a href="#The_Service_Design">The Service
Design</a>)  describes  the service api and and the service class hierarchy.&nbsp;
This  is followed  by a discussion of group keys and their relationship to
the composite design  (<a href="#Groups_Keys_and_Service_Names">Groups, Keys 
and Service Names</a>)  .&nbsp; These first 3 sections are aimed at developers, 
and if you are interested  only in deploying a composite service, you 
can skim them or skip them entirely.&nbsp;  The next 3 sections are aimed 
at deployers. &nbsp;They describe the process of composite service assembly 
   (<a href="#Assembling_the_Composite">Assembling  the Composite</a>), the 
configuration  file that controls the assembly process  (<a
 href="#Configuring_the_Composite">Configuring the Composite</a>) and  the 
     design of the LDAP group store that ships with uPortal 2.1 (<a
 href="#The_LDAP_Group_Store">The LDAP Group Store</a>).&nbsp; The last section
      (<a href="#Next_Steps">Next Steps</a>) presents a very general outline
for getting started with groups. &nbsp;&nbsp;</p>

<p>Unless otherwise noted, all referenced classes are in the <code>org.jasig.portal.groups</code>
 package. &nbsp;I'm assuming some familiarity with the basic groups
types, <code>IGroupMember</code>, <code>IEntity</code> and <code>IEntityGroup</code>, 
and with the service fa&ccedil;ade, <code>org.jasig.portal.services.GroupService</code>, 
which have changed little since uPortal 2.0.&nbsp; The best source 
for information about these types is javadoc for <code>org.jasig.portal.groups</code>. 
     &nbsp;The following terms are used interchangeably: IEntityGroup and 
group; IGroupMember and group member; composite group service and service.&nbsp; 
Depending on the context, entity may refer to an <code>IEntity</code> 
or to the underlying entity that is referred to by the <code>IEntity</code>.&nbsp; </p>

      <h4><a name="Goals_and_Rationale_of_the_Composite"></a>Goals and Rationale
      of the Composite Service</h4>
                                                                       
<p>Many institutions have group information that is not under the 
control of the portal, more often than not in an LDAP server. &nbsp;
In addition, some organizations have this information spread over a number 
of external sources. &nbsp; In order to use it, the portal needs a way to 
adapt external group information to the portal groups design and to combine group 
information from multiple sources.&nbsp; An LDAP adaptor, for instance, 
would let the portal recognize attributes in LDAP as group memberships.&nbsp; 
These memberships, supplemented by memberships stored in the reference 
portal database, could be associated with permissions that govern 
what a user could and could not do.  In this way, portal authorization could 
be driven from LDAP and modified from within the portal. &nbsp; </p>

<p>The composite groups system is a framework for creating and
managing   these   adaptors.&nbsp; Its job is to aggregate group information
from a  variety  of sources and present it in a consistent format to clients
who can remain  unaware of its origins.&nbsp; In fact, group service clients
never interact  directly even with the composite group service.&nbsp; A client
makes a request  to the service fa&ccedil;ade to obtain a group member, and
the group member  acts as an entry point into the composite group system. &nbsp;
Once the client has a reference to a new or pre-existing group member, 
it makes subsequent requests to the group member itself, and henceforth, 
the client can ignore  the service of origin of any group member it navigates 
to. &nbsp; </p>
                                                            
      <h4><a name="The_Service_Design"></a>The Service Design</h4>
            <i>The Service Hierarchy.</i>&nbsp; The composite group service 
 api   is   divided  among 3 service types, <code>IComponentGroupService</code>, 
         <code>ICompositeGroupService</code>     and <code>IIndividualGroupService</code>, 
   each of which defines responsibilities     for a specific service role.&nbsp; 
   An <code>IComponentGroupService</code>     is a composite <i>component</i>.&nbsp; 
   It is concerned with composite service    assembly and with identifying 
 components  in the composite.&nbsp; The <code>ICompositeGroupService</code> 
    represents  the composition as a whole, encapsulating service components 
  and  delegating  requests for group services.&nbsp; The <code>IIndividualGroupService</code>
       defines responsibilities for a specific group service that reads and
  possibly     writes groups.&nbsp; It is the<i> leaf component</i> in the
 composite.&nbsp;     Together, they form the following class hierarchy:
                                                                   
      <blockquote><code>IComponentGroupService</code><br>
                 <code> &nbsp; ICompositeGroupService extends IComponentGroupService</code><br>
                 <code> &nbsp;&nbsp;&nbsp; IIndividualGroupService extends
 ICompositeGroupService</code><br>
                 <code> </code></blockquote>
                                                                        
  
      <p><i>IComponentGroupService.</i>&nbsp; An <code>IComponentGroupService</code> 
       can get and set its name and, as a component in a composite, answer 
 its    component  group services.&nbsp; A component service can either contain 
   other  component  services or be a leaf service and serve groups.&nbsp; 
 While  it  may seem unlikely  that services with groups of IPersons, like 
 LDAP or  ERP-based  services would  be nested inside of other service components, 
  services with  groups of IChannels  actually might, particularly those representing
   groups  of channels running  on remote portals.&nbsp; &nbsp;    </p>
                                                                       
      <blockquote><code>public interface <b>IComponentGroupService</b> {</code><br>
              <code> &nbsp; public Map getComponentServices();</code><br>
              <code> &nbsp; public Name getServiceName();</code><br>
              <code> &nbsp; public boolean isLeafService();</code><br>
              <code> &nbsp; public void setServiceName(Name newServiceName);</code><br>
              <code> }</code>
                   <br>
               </blockquote>
                                                                       
      <p>    The reference implementation is a true composite only at service
    start-up,     when each <code>IComponentGroupService</code> performs
a  recursive   retrieval    of its components.&nbsp; Once the elements of
this  composite   have been retrieved,   the composite service keeps its
components  in a one-dimensional   collection.   &nbsp;Since it does not
contain nested  group services, the  reference composite group service does
not have a direct  implementation of        <code>IComponentGroupService</code>
but only implementations  of its  subtypes, <code>ICompositeGroupService</code>
and <code>IIndividualGroupService</code>.    &nbsp;</p>
                                                                        
   
      <p><i>    ICompositeGroupService.</i>&nbsp; An <code>ICompositeGroupService</code> 
       represents the entire composition.&nbsp; It is responsible for delegating 
       requests to the appropriate component service(s) and for aggregating 
  results.&nbsp;     Requests come to the composite from either the outside, 
  (the service fa&ccedil;ade),     or the inside, (a component service).&nbsp;&nbsp; 
  Some requests can be  handled   by a single group service, for example, 
a  request to find a specific  group   <code>(findGroup()</code>, <code>newGroup()</code>, 
   etc.)&nbsp; Other  requests  may span some or all of the component services, 
   for example, a request to  find groups that contain a particular group 
member   (<code>findContainingGroups()</code>)     or a request to find groups 
whose   names contain a particular String (<code>searchForGroups()</code>). &nbsp;</p>

     <blockquote><code>public interface <b>ICompositeGroupService</b> extends
   IComponentGroupService        </code><br>
              <code> {</code><br>
              <code> &nbsp; public Iterator findContainingGroups(IGroupMember 
   gm)     </code><br>
              <code> &nbsp;&nbsp;&nbsp; throws GroupsException;</code><br>
              <code> &nbsp; public IEntityGroup findGroup(String key) throws
  GroupsException;</code><br>
              <code> &nbsp; public ILockableEntityGroup findGroupWithLock(String 
     key,   String owner) </code><br>
              <code> &nbsp;&nbsp;&nbsp; throws GroupsException;</code><br>
              <code> &nbsp; public IEntity getEntity(String key, Class type)
          </code><br>
              <code> &nbsp;&nbsp;&nbsp; throws GroupsException;</code><br>
              <code> &nbsp; public IGroupMember getGroupMember(String key,
 Class     type)     </code><br>
              <code> &nbsp;&nbsp;&nbsp; throws GroupsException;</code><br>
              <code> &nbsp; public IGroupMember getGroupMember(EntityIdentifier</code><br>
              <code> &nbsp;&nbsp;&nbsp; underlyingEntityIdentifier) throws
 GroupsException;</code><br>
              <code> &nbsp; public IEntityGroup newGroup(Class type, Name 
serviceName)          </code><br>
              <code> &nbsp;&nbsp;&nbsp; throws GroupsException;</code><br>
              <code> &nbsp; public EntityIdentifier[] searchForEntities</code><br>
              <code> &nbsp;&nbsp;&nbsp; (String query, int method, Class
type)      </code><br>
              <code> &nbsp;&nbsp;&nbsp;&nbsp; throws GroupsException;</code><br>
              <code> &nbsp; public EntityIdentifier[] searchForEntities</code><br>
              <code> &nbsp;&nbsp;&nbsp; (String query, int method, Class
type,    IEntityGroup    ancestor) </code><br>
              <code> &nbsp;&nbsp;&nbsp; throws GroupsException;</code><br>
              <code> &nbsp; public EntityIdentifier[] searchForGroups</code><br>
              <code> &nbsp;&nbsp;&nbsp; (String query, int method, Class
leaftype)         </code><br>
              <code> &nbsp;&nbsp;&nbsp; throws GroupsException;</code><br>
              <code> &nbsp; public EntityIdentifier[] searchForGroups</code><br>
              <code> &nbsp;&nbsp;&nbsp; (String query, int method, Class
leaftype,       IEntityGroup  ancestor)</code><br>
              <code> &nbsp;&nbsp;&nbsp; throws GroupsException;</code><br>
              <code> }</code>                                                                      
<br>
                 <code> </code></blockquote>
                                                                         
     
      <p><i>IIndividualGroupService.</i>&nbsp; The third type, IIndividualGroupService
       defines the methods that a specific or leaf group service uses to
       read and write groups.&nbsp; IIndividualGroupService inherits<code>
       find()</code> methods from ICompositeGroupService, but whereas an ICompositeGroupService 
       would probably delegate these requests, an IIndividualGroupService 
       would more likely perform them itself.&nbsp; In addition, an IIndividualGroupService 
       must answer if it can be updated (<code>isEditable()</code>), and more specifically, if it 
       is possible to edit a particular group (<code>isEditable(IEntityGroup group)</code>).&nbsp; 
       An attempt to update a group that is not editable should throw a GroupsException. &nbsp;</p>
                                                                        
   
      <blockquote><code>public interface <b>IIndividualGroupService</b> extends
   ICompositeGroupService     </code><br>
              <code>    {</code><br>
              <code>    &nbsp; public void deleteGroup(IEntityGroup group)
         </code><br>
              <code>    &nbsp;&nbsp;&nbsp; throws GroupsException;</code><br>
              <code>    &nbsp; public IEntityGroup findGroup(CompositeEntityIdentifier
      ent)</code><br>
              <code>    &nbsp;&nbsp;&nbsp; throws GroupsException;</code><br>
              <code>    &nbsp; public Iterator findMembers(IEntityGroup group)
           </code><br>
              <code>    &nbsp;&nbsp;&nbsp; throws GroupsException;</code><br>
              <code>    &nbsp; public boolean isEditable();</code><br>
              <code>    &nbsp; public boolean isEditable(IEntityGroup group)
          </code><br>
              <code>    &nbsp;&nbsp;&nbsp; throws GroupsException;</code><br>
              <code>    &nbsp; public IEntityGroup newGroup(Class type) </code><br>
              <code>    &nbsp;&nbsp;&nbsp; throws GroupsException;</code><br>
              <code>    &nbsp; public void updateGroup(IEntityGroup group)
         </code><br>
              <code>    &nbsp;&nbsp;&nbsp; throws GroupsException;</code><br>
              <code>    &nbsp; public void updateGroupMembers(IEntityGroup
 group)      </code><br>
              <code>    &nbsp;&nbsp;&nbsp; throws GroupsException;</code><br>
              <code>    }</code>                                
                                                                        
                      <br>
            </blockquote>
                                                                        
       
      <p>The reference implementation, <code>ReferenceIndividualGroupService</code>,
      delegates most requests to one of three sub-components, an <code>IEntityGroupStore</code>,
      an <code>IEntityStore</code> and an <code>IEntitySearcher</code>. &nbsp;It
      also may use the portal's Entity Locking and Entity Caching services.
  &nbsp;</p>
                                                                         
     
      <h4><a name="Groups_Keys_and_Service_Names"></a>Groups, Keys and Service
    Names</h4>
                                                                        
   
      <p><i>Component Services and Their Names.</i>&nbsp; Once it has been
    assembled,     the composite structure of the group service is reflected
   in the names  given   to services, which are instances of <code>javax.naming.Name</code>
   with a node  for each   nested service.&nbsp; A service named "columbia"
  contained by a service named  "remoteChannels" would be named "remoteChannels.columbia&#8221;.&nbsp;
     Since a component cannot be expected to know in advance which components
    will contain  it, the fully-qualified service name of a given component
  may  not be known  until the composite is fully assembled.&nbsp; In the
reference    implementation,  the service name is built up node by node as
the composite    is composed. &nbsp;</p>
                                                                        
       
      <p><i>IEntityGroups and Their Service Names.</i>&nbsp; In a composite
    service,     the significance of service identifiers -- names -- is that
   they let us   find  the specific service that can answer a request.&nbsp;
   They also uniquely    identify individual service entries, in this case
 groups,   whose keys may   not be unique across different services.&nbsp;
 Thus, a client  wishing to  find a group called "English101" in a component
 service named  "ldap" needs  to ask the composite service for "ldap.English101"
 rather than  "sis.English101"    or simply "English101".&nbsp; The ldap
service  may know  the group as "English101"    but the client must know
it as "ldap.English101".     &nbsp;</p>
                                                                        
   
      <p>    Conversely, for a service to support foreign entries, where
an entry   from   one service participates in some way in another service,
the foreign   entry   must be able to answer its home service identifier
so that it can   be retrieved,   if need arises, from its service of origin.&nbsp;
    This means   that for a group  to be a member of a group in another service,
    the member   group must be able  to answer its home service name.&nbsp;&nbsp;
    As of version   2.1, <code>IEntityGroup</code> inherits from <code>org.jasig.portal.IBasicEntity</code>,
      therefore a group can already  answer a key and a type, in the form
of   an   <code>org.jasig.portal.EntityIdentifier</code>.&nbsp;  In the reference
    implementation,  a group (an instance of <code>EntityGroupImpl</code>)
        answers a subclass of <code>EntityIdentifier</code>,&nbsp; <code>CompositeEntityIdentifier</code>,
        whose key contains the fully-qualified service name in addition to
 the    native   service key. &nbsp;</p>
                                                                        
       
      <p><i>Group Members and Their Keys.</i>&nbsp; From the point of view
    of the     composite group service, the key of a group is its key in
the    home service     concatenated to its fully-qualified service name
(e.g.,   &#8220;ldap&#8221; + &#8220;English101&#8221;     = &#8220;ldap.English101&#8221;).&nbsp; By contrast,
the key   of an entity is simply   its  native key, and all component group
services   are obligated to know it  by that key.&nbsp; Thus, to get containing
groups   for IPerson &#8220;kweiner&#8221;,  the client would ask the service fa&ccedil;ade
for   an IGroupMember for IPerson    &#8220;kweiner&#8221;, not &#8220;ldap.kweiner&#8221; or &#8220;local.kweiner&#8221;,
    and then ask the group   member to get containing groups.&nbsp; The composite
    service would ask each   of its components to get containing groups for
  group  member IPerson kweiner,   and each component service would be obligated
  to  recognize membership information    for IPerson kweiner, rather than
 IPerson  ldap.kweiner, IPerson local.kweiner,    etc.&nbsp; This changes
our previous  specification for a composite group   service, but we decided
to remove entity  key translation from the group service  api because it
seemed overly burdensome  and frequently unnecessary, though  it may still
be required internally when  an ICompositeGroupService searches  for entities.
&nbsp;    </p>
                                                                       
      <h4><a name="Assembling_the_Composite"></a>Assembling the Composite</h4>
                                                                       
      <p>    In the reference implementation, the composite service is an
    instance   of  <code>org.jasig.portal.groups.ReferenceCompositeGroupService</code> 
    and  is responsible for assembling the composite structure. &nbsp;Each 
 leaf   component is an instance of <code>ReferenceIndividualGroupService</code> 
   and is customized with an <code>IEntityGroupStore</code>, an <code>IEntityStore</code> 
    and an <code>IEntitySearcher</code>. &nbsp;A factory class for each of 
 these    types is specified in the configuration file. &nbsp;</p>
                                                                        
      <p><i>The configuration file.</i>&nbsp; The composite configuration
    is stored     in xml format in <code>properties/groups/compositeGroupServices.xml</code>.&nbsp; 
       The group service deployer edits this file to control the composition 
   of  the composite group service. &nbsp;The root element of this document 
   is a service list whose <code>service</code>  elements describe group services
     that are components of the top-level composite  service.&nbsp; The configuration
     document is represented in Java as a <code>GroupServiceConfiguration</code>,
        essentially a parser with a Map of <code>ComponentServiceDescriptors</code>.&nbsp; 
       Each <code>ComponentServiceDescriptor</code> is itself a Map containing 
     the  elements and attributes of a single <code>service</code> element.&nbsp; 
     These  elements are:</p>
                                                                        
              
      <blockquote>                                                      
                                      
        <table cellpadding="2" cellspacing="2" border="2" width="66%">
                   <tbody>
                     <tr>
                       <td valign="top" bgcolor="#ffffff">name<br>
                       </td>
                       <td valign="top" bgcolor="#ffffff">required<br>
                       </td>
                     </tr>
                     <tr>
                       <td valign="top" bgcolor="#ffffff">service_factory<br>
                       </td>
                       <td valign="top" bgcolor="#ffffff">required<br>
                       </td>
                     </tr>
                     <tr>
                       <td valign="top">entity_store_factory<br>
                       </td>
                       <td valign="top">required for reference implementation<br>
                       </td>
                     </tr>
                     <tr>
                       <td valign="top">group_store_factory<br>
                       </td>
                       <td valign="top">required for reference implementation<br>
                       </td>
                     </tr>
                     <tr>
                       <td valign="top">entity_searcher_factory<br>
                       </td>
                       <td valign="top">required for reference implementation<br>
                       </td>
                     </tr>
                     <tr>
                       <td valign="top">internally_managed<br>
                       </td>
                       <td valign="top">optional, defaults to false<br>
                       </td>
                     </tr>
                     <tr>
                       <td valign="top">caching_enabled<br>
                       </td>
                       <td valign="top">optional, defaults to false<br>
                       </td>
                     </tr>
                                                                        
                                                                
          </tbody>                                                      
                                      
        </table>
               </blockquote>
               <br>
                Here is the service entry for the reference portal group
service,     which is named "local":                                    
                                 
      <blockquote><small>&lt;service&gt;</small><br>
               <small>       &nbsp;&nbsp;&nbsp; &lt;name&gt;local&lt;/name&gt;</small><br>
               <small>       &nbsp;&nbsp;&nbsp; &lt;service_factory&gt;org.jasig.portal.groups.ReferenceIndividualGroupServiceFactory&lt;/service_factory&gt;</small><br>
               <small>       &nbsp;&nbsp;&nbsp; &lt;entity_store_factory&gt;org.jasig.portal.groups.ReferenceEntityStoreFactory&lt;/entity_store_factory&gt;</small><br>
               <small>       &nbsp; &nbsp; &lt;group_store_factory&gt;org.jasig.portal.groups.ReferenceEntityGroupStoreFactory&lt;/group_store_factory&gt;</small><br>
               <small>      &nbsp; &nbsp; &lt;entity_searcher_factory&gt;org.jasig.portal.groups.ReferenceEntitySearcherFactory&lt;/entity_searcher_factory&gt;</small><br>
               <small>       &nbsp;&nbsp;&nbsp; &lt;internally_managed&gt;true&lt;/internally_managed&gt;</small><br>
               <small>       &nbsp;&nbsp;&nbsp; &lt;caching_enabled&gt;true&lt;/caching_enabled&gt;</small><br>
               <small>       &lt;/service&gt;</small> <br>
             </blockquote>
                                                                        
    
      <p><i> Creating the component services.</i>&nbsp; On service start-up,
    the    composite  service gets a <code>GroupServiceConfiguration</code>
  and  asks    it for its service descriptors.&nbsp; The composite passes
each  description     to the appropriate service factory and gets back a
new service  instance.    &nbsp;</p>
                                                                        
   
      <p>    If the component is an individual or <i>leaf</i> service, the
    factory   creates  an <code>IIndividualGroupService</code>, in the reference
    implementation,    a <code>ReferenceIndividualGroupService</code>.&nbsp;
   The service instance    uses the descriptor to customize itself, for example,
    by getting its group    store from the group store factory designated
in   the descriptor.&nbsp; When   the component has been initialized, the
composite    service adds the new service   to its service Map. &nbsp;</p>
                                                                        
   
      <p>    If the service is not a leaf but a component service, the composite
      service   asks it for its component services, which starts a recursive
   retrieval   of   leaf services.&nbsp; The composite service completes
the    naming of each  leaf  service by prepending the name of the top-level
component    to the service   name, and then adds each leaf component to
its service  Map.   &nbsp;</p>
                                                                        
   
      <p>    At the end of the process, non-leaf components have been eliminated,
      and   the composite service may have multiple instances of the same
      <code>IIndividualGroupService</code>        implementation, each customized
 by its own service descriptor. &nbsp;       </p>
                                                                       
      <h4><a name="Configuring_the_Composite"></a>Configuring the Composite</h4>
                                                               
      <p>         The configuration described in <code>compositeGroupServices.xml</code>
       is made available to group service classes via the utility class <code>GroupServiceConfiguration</code>.&nbsp;
        This class exposes the <code>servicelist</code> attributes and <code>service</code> 
       elements via:       </p>
                                                               
      <blockquote><code>public Map getAttributes();<br>
                 public List getServiceDescriptors()<br>
               </code></blockquote>
                                                                
      <p>         uPortal 2.1 ships with the following configuration:<br>
                </p>
                                                                 
      <blockquote><small>&lt;?xml version="1.0"?&gt;</small><br>
               <small>         &lt;!-- $Revision$ --&gt;</small><br>
               <small>         &lt;!--</small><br>
               <small>         This list of component group services is processed 
   by the composite,   or  "root" service as it assembles itself.&nbsp; Each 
   service element has   2 required  elements: name and service_factory.&nbsp; 
   The values of all service  elements  are delivered to the service_factory. 
   &nbsp;</small><br>
               <small>         --&gt;</small><br>
               <small>         </small><br>
               <small>         &lt;servicelist defaultService="local" compositeFactory="org.jasig.portal.groups.ReferenceCompositeGroupServiceFactory"&gt;</small><br>
               <small>         &nbsp; &lt;service&gt;</small><br>
               <small>         &nbsp;&nbsp;&nbsp; &lt;name&gt;local&lt;/name&gt;</small><br>
               <small>         &nbsp;&nbsp;&nbsp; &lt;service_factory&gt;org.jasig.portal.groups.ReferenceIndividualGroupServiceFactory&lt;/service_factory&gt;</small><br>
               <small>         &nbsp;&nbsp;&nbsp; &lt;entity_store_factory&gt;org.jasig.portal.groups.ReferenceEntityStoreFactory&lt;/entity_store_factory&gt;</small><br>
               <small>         &nbsp;&nbsp;&nbsp; &lt;group_store_factory&gt;org.jasig.portal.groups.ReferenceEntityGroupStoreFactory&lt;/group_store_factory&gt;</small><br>
               <small>         &nbsp;&nbsp;&nbsp; &lt;entity_searcher_factory&gt;org.jasig.portal.groups.ReferenceEntitySearcherFactory&lt;/entity_searcher_factory&gt;</small><br>
               <small>         &nbsp;&nbsp;&nbsp; &lt;internally_managed&gt;true&lt;/internally_managed&gt;</small><br>
               <small>         &nbsp;&nbsp;&nbsp; &lt;caching_enabled&gt;true&lt;/caching_enabled&gt;</small><br>
               <small>         &nbsp; &lt;/service&gt;</small><br>
               <small>         </small><br>
               <small>         &lt;!--</small><br>
               <small>         &nbsp; &lt;service&gt;</small><br>
               <small>         &nbsp;&nbsp;&nbsp; &lt;name&gt;ldap&lt;/name&gt;</small><br>
               <small>         &nbsp;&nbsp;&nbsp; &lt;service_factory&gt;org.jasig.portal.groups.ReferenceIndividualGroupServiceFactory&lt;/service_factory&gt;</small><br>
               <small>         &nbsp;&nbsp;&nbsp; &lt;entity_store_factory&gt;org.jasig.portal.groups.ldap.LDAPEntityStoreFactory&lt;/entity_store_factory&gt;</small><br>
               <small>         &nbsp;&nbsp;&nbsp; &lt;group_store_factory&gt;org.jasig.portal.groups.ldap.LDAPGroupStoreFactory&lt;/group_store_factory&gt;</small><br>
               <small>         &nbsp;&nbsp;&nbsp; &lt;entity_searcher_factory&gt;org.jasig.portal.groups.ldap.LDAPEntitySearcherFactory&lt;/entity_searcher_factory&gt;</small><br>
               <small>         &nbsp;&nbsp;&nbsp; &lt;internally_managed&gt;false&lt;/internally_managed&gt;</small><br>
               <small>         &nbsp;&nbsp;&nbsp; &lt;caching_enabled&gt;false&lt;/caching_enabled&gt;</small><br>
               <small>         &nbsp; &lt;/service&gt;</small><br>
               <small>         --&gt;</small><br>
               <small>         </small><br>
               <small>         &lt;/servicelist&gt;</small><br>
             </blockquote>
               <br>
                                                              
      <p>Note that the servicelist element has 2 attributes and the "ldap" service entry is commented out. &nbsp;</p>

<p><i>Required servicelist Attributes.</i>&nbsp; The attributes <code>defaultService</code> and 
<code>compositeFactory</code> are both required. &nbsp;</p>
                                                                 
      <blockquote><small>&lt;servicelist defaultService="<b>local</b>" </small><br>
               <small>         &nbsp;compositeFactory="<b>org.jasig.portal.groups.ReferenceCompositeGroupServiceFactory</b>"</small><code></code><br>
               <code>         </code></blockquote>

      <p>The <code>defaultService</code> is the service that responds to requests for new group 
members when the request does not include a service name, e.g., <code>GroupService.newGroup(Class 
type)</code>.&nbsp; The entity factory in the default service supplies those <code>IEntities</code> 
that are entry points into the composite group service (group members not obtained from other group 
members.)&nbsp; One way to substitute  an  alternate <code>IEntity</code> implementation for these 
entry points would be to change the default service.&nbsp; (Another would be to change the 
<code>entity_store_factory</code> element in the default service.)&nbsp; The <code>compositeFactory</code> 
attribute designates the class that creates the composite service instance.&nbsp;  You would 
change its value if you  wanted to substitute your own composite service 
implementation (and still use the configuration file.) &nbsp;</p>
                                              
      <p><i>Additional servicelist Attributes</i>.&nbsp; The <code>GroupServiceConfiguration</code>
        stores all servicelist attributes.&nbsp; If you wish to make additional
      composite  service attributes available to one or more of your component
     services, you  can add them to the configuration document and retrieve
  them   via:</p>
                                                                        
          
      <blockquote><code>String myAttribute = (String) </code><br>
                 <code> &nbsp; GroupServiceConfiguration.getAttributes().get("myAttribute");</code><br>
                 <code> </code></blockquote>
               <br>
                                                                 
      <p><i>The servicelist elements</i>.&nbsp; The elements of the <code>servicelist</code> 
       describe<i> top-level</i> component services.&nbsp; The default configuration 
       contains 2 <code>service</code> elements, "local", which describes 
the    group   service whose group store is the reference portal database 
and "ldap",   which   is commented out.&nbsp; Both of these are leaf services.&nbsp; 
 The   service   named "local" has the following entry:         </p>
                                                                 
      <blockquote><small>&lt;service&gt;</small><br>
               <small>         &nbsp;&nbsp;&nbsp; &lt;name&gt;local&lt;/name&gt;</small><br>
               <small>         &nbsp;&nbsp;&nbsp; &lt;service_factory&gt;org.jasig.portal.groups.ReferenceIndividualGroupServiceFactory&lt;/service_factory&gt;</small><br>
               <small>         &nbsp;&nbsp;&nbsp; &lt;entity_store_factory&gt;org.jasig.portal.groups.ReferenceEntityStoreFactory&lt;/entity_store_factory&gt;</small><br>
               <small>         &nbsp;&nbsp;&nbsp; &lt;group_store_factory&gt;org.jasig.portal.groups.ReferenceEntityGroupStoreFactory&lt;/group_store_factory&gt;</small><br>
               <small>         &nbsp;&nbsp;&nbsp; &lt;entity_searcher_factory&gt;org.jasig.portal.groups.ReferenceEntitySearcherFactory&lt;/entity_searcher_factory&gt;</small><br>
               <small>         &nbsp;&nbsp;&nbsp; &lt;internally_managed&gt;true&lt;/internally_managed&gt;</small><br>
               <small>         &nbsp;&nbsp;&nbsp; &lt;caching_enabled&gt;true&lt;/caching_enabled&gt;</small><br>
               <small>         &lt;/service&gt;</small><code></code><br>
               <code>         </code></blockquote>
                                                                        
   
      <p><i>Child Elements of the service element.</i>&nbsp; Within the <code>service</code> 
       element, the <code>name</code> and <code>service_factory</code> child 
   elements    are required for the assembly of the composite.&nbsp; In addition, 
   the reference   implementation of <code>IIndividualGroupService</code> 
requires    all child   elements except <code>internally_managed</code> and 
            <code>caching_enabled</code>       for a fully-functioning leaf 
service.&nbsp;  The elements are as follows:</p>
                                                                        
       
      <p><i>service_factory</i> designates the class name of the factory
that creates     the service implementation.&nbsp; You only need to change
this value if   you  are substituting your own implementation for the reference
    service implementation,    <code>ReferenceIndividualGroupService</code>.
   &nbsp;</p>
                                                               
      <p><i>name</i> of the service is significant if you need to use a group
       from   the service as a composite service entry point, since you find
   such   a group   using a key that contains both the native key and the
service    name,  e.g.,       </p>
                                                                        
    
      <blockquote><code>String nativeKey = "100";</code><br>
                 <code> String serviceName = "<b>local</b>";</code><br>
                 <code> String groupKey = serviceName + "." + nativeKey;</code><br>
                 <code> IGroupMember myGroup = GroupService.findGroup(groupKey);</code><br>
               </blockquote>
                                                                        
       
      <p><i>Warning:</i>&nbsp; do not change the service name of an already-deployed
        group service.&nbsp; The service name is part of the member key in
 membership       entries for member groups (groups that are members of other
 groups.)&nbsp;       If you change it, you must change the keys of all membership
 entries  for    member groups originating in that service. &nbsp;</p>
                                                                        
       
      <p><i>entity_store_factory</i> is the factory class name for the entity
    store,     the service factory for <code>IEntities</code>, group members
   that can  be  used to search the composite service for entity memberships.&nbsp;
    Since   the keys of <code>IEntities</code> do not contain service names,
   an entity   store can be shared by multiple group services.&nbsp; You
would    change this   value only if you were substituting your own implementation
   of <code>IEntityStore</code>    for the reference implementation. &nbsp;</p>
                                                                        
       
      <p><i>group_store_factory</i> is the factory class name for the group
    store,     the adaptor that connects the group service with the native
 source   of groups    information.&nbsp; Although entity stores can be shared,
 each   service will    almost certainly have its own group store.&nbsp;
The  group   store for "local", <code>RDBMEntityGroupStore</code>,  refers
to tables   in the reference portal database, contains sql statements  and
retrieves   group  information via jdbc.&nbsp; The group store for "ldap",
       <code>org.jasig.portal.groups.ldap.LDAPGroupStore</code>,      refers
 to an LDAP database and submits LDAP queries over <code>ldap://</code>.
     &nbsp;</p>
                                                                        
       
      <p><i>entity_searcher_factory</i> is the factory class name for the
    entity    searcher implementation.&nbsp; The entity searcher is a class
  that  refers    to one or more portal entity stores and returns <code>EntityIdentifiers</code> 
       for potential group members.&nbsp; It is likely, though by no means 
 certain,      that each group service would have its own entity searcher 
implementation.&nbsp;      The entity searcher for "local" returns <code>EntityIdentifiers</code> 
    for   <code>IChannels</code> and <code>IPersons</code> from the reference 
    portal   database.&nbsp; The entity searcher for "ldap" returns <code>EntityIdentifiers</code> 
       for <code>IPersons</code> from the same LDAP database that contains 
 its    group  information. &nbsp;</p>
                                                                        
       
      <p><i>internally_managed</i> contains a boolean value, either <i>true
         </i> or <i>false</i>.&nbsp;     If a service is internally-managed, 
  it is under the  control of the portal     and presumably is capable of 
writing  as well as  reading groups.&nbsp; In   the reference implementation, 
if       <code>internally_managed</code>   is <i>true</i>,   the service will
attempt to satisfy a request to add,  update or  delete a  group.&nbsp; 
If it is not internally-managed, an attempt  to update  a group  will throw
 a <code>GroupsException</code>.&nbsp; An alternate  implementation    of
      <code>IIndividualGroupService</code>  could be more selective and decide
    if updates are allowed on a group-by-group  basis. &nbsp;</p>
                                                                        
       
      <p><i>caching_enabled</i> has a boolean value, either <i>true</i> or 
        <i>false</i>,  which     controls whether the component service uses 
  the portal's entity  caching   service  to cache groups.&nbsp; The value 
 for the "local" service  is set  to <i>true</i> to  eliminate excess database 
  calls.&nbsp; It is set to <i>false</i> for  "ldap" because  the ldap service 
  has its own caching mechanism. &nbsp;</p>
                <i>The ldap service</i>.&nbsp; Comment in the service element 
  named "ldap"    if  you  want to hook up an ldap group service:        
                                        
      <blockquote>         &nbsp;<small> &lt;service&gt;</small><br>
               <small>         &nbsp;&nbsp;&nbsp; &lt;name&gt;ldap&lt;/name&gt;</small><br>
               <small>         &nbsp;&nbsp;&nbsp; &lt;service_factory&gt;org.jasig.portal.groups.ReferenceIndividualGroupServiceFactory&lt;/service_factory&gt;</small><br>
               <small>         &nbsp;&nbsp;&nbsp; &lt;entity_store_factory&gt;org.jasig.portal.groups.ldap.LDAPEntityStoreFactory&lt;/entity_store_factory&gt;</small><br>
               <small>         &nbsp;&nbsp;&nbsp; &lt;group_store_factory&gt;org.jasig.portal.groups.ldap.LDAPGroupStoreFactory&lt;/group_store_factory&gt;</small><br>
               <small>         &nbsp;&nbsp;&nbsp; &lt;entity_searcher_factory&gt;org.jasig.portal.groups.ldap.LDAPEntitySearcherFactory&lt;/entity_searcher_factory&gt;</small><br>
               <small>         &nbsp;&nbsp;&nbsp; &lt;internally_managed&gt;false&lt;/internally_managed&gt;</small><br>
               <small>         &nbsp;&nbsp;&nbsp; &lt;caching_enabled&gt;false&lt;/caching_enabled&gt;</small><br>
               <small>         &nbsp; &lt;/service&gt;</small><br>
               <big>    </big></blockquote>
            <br>
                Note that the value of <code>service_factory</code> is the
 same   for   both   the "local" and "ldap" service elements.&nbsp; This
is  because   both   the local  and ldap group services are instances of
      <code>ReferenceIndividualGroupService</code>,        customized by
their respective service configurations.&nbsp; The entries       for <code>entity_store_factory</code>,
      <code>group_store_factory</code>     and  <code>entity_searcher_factory</code>
all designate different factory     classes.&nbsp;&nbsp;  Nonetheless, they
all return the same (singleton)   instance  of <code>org.jasig.portal.groups.ldap.LDAPGroupStore</code>, 
  which implements  the <code>IEntityStore</code>, <code>IEntityGroupStore</code> 
    and <code>IEntitySearcher</code>  interfaces.&nbsp; The <code>internally_managed</code> 
    element is set to <i>false</i> because in most environments, the LDAP 
store  will   not be updatable  by the portal and in any event, <code>LDAPGroupStore</code> 
    does not support  updates. &nbsp;                                    
                           
      <h4><a name="The_LDAP_Group_Store"></a>The LDAP Group Store</h4>
                                                                       
      <p>    The LDAP group store gets its entity memberships from LDAP and
    its   group structure   from a configuration file, <code>properties/groups/LDAPGroupStoreConfig.xml</code>.&nbsp;
        The configuration file also defines the location of the native group
   store.&nbsp;     (The dtd for <code>LDAPGroupStoreConfig.xml</code> is
      <code>LDAPGroupStore.dtd</code>.)&nbsp;       Understanding the configuration
 file is crucial to understanding how  the    group store works. &nbsp;</p>
                                                                
      <p> <i>Configuration file elements.</i>&nbsp; The configuration file
    has   a  single  <code>config</code> element that describes the LDAP
connection       and some number  of <code>group</code>  elements that establish
the groups      structure and ultimately, map  LDAP queries  to groups.&nbsp;
The <code>config</code>      element currently points to the  Columbia University
 public LDAP server:           </p>
                                                                         
     
      <blockquote><small>&lt;config&gt;<br>
                  &nbsp;&nbsp; &nbsp;&lt;url&gt;ldap://ldap.columbia.edu:389/o=Columbia%20University,c=US&lt;/url&gt;<br>
                  &nbsp;&nbsp; &nbsp;&lt;logonid&gt;&lt;/logonid&gt;<br>
                  &nbsp;&nbsp; &nbsp;&lt;logonpassword&gt;&lt;/logonpassword&gt;<br>
                  &nbsp;&nbsp; &nbsp;&lt;keyfield&gt;uni&lt;/keyfield&gt;<br>
                  &nbsp;&nbsp; &nbsp;&lt;namefield&gt;cn&lt;/namefield&gt;<br>
                  &nbsp;&nbsp; &nbsp;&lt;usercontext&gt;&lt;/usercontext&gt;<br>
                  &nbsp;&nbsp; &nbsp;&lt;refresh-minutes&gt;120&lt;/refresh-minutes&gt;<br>
                  &lt;/config&gt;<br>
               </small></blockquote>
                                                                        
 
      <p><i>Group elements.</i>&nbsp; The <code>group</code> element contains
      the  <code>IEntityGroup</code> attributes <code>key</code>, <code>name</code> 
      and <code>description</code>.&nbsp; Just as an <code>IEntityGroup</code> 
     can contain groups and entities, a <code>group</code> element can contain 
     other member <code>group</code> elements, and it can contain member entities
     in the form of a single <code>entity-set</code>.&nbsp; At its simplest,
   an&nbsp;<code>entity-set</code>    can contain a <code>filter</code> element
   that defines an LDAP query that    returns entities.&nbsp; Or it may contain
   a <code>union</code>, <code>intersection</code>,    <code>difference</code> 
   or <code>subtract</code> element, which, in turn,    contains&nbsp;<code>entity-sets</code> 
   whose results are combined through    one of the following operations: 
      </p>
                                                                        
    
      <blockquote>                                                      
                                      
        <table cellpadding="2" cellspacing="2" border="1" width="66%">
                   <tbody>
                     <tr>
                       <td valign="top">union<br>
                       </td>
                       <td valign="top">all entities from all contained entity-sets<br>
                       </td>
                     </tr>
                     <tr>
                       <td valign="top">intersection<br>
                       </td>
                       <td valign="top">all common entities from all contained
   entity-sets<br>
                       </td>
                     </tr>
                     <tr>
                       <td valign="top">difference<br>
                       </td>
                       <td valign="top">all entities that occur in only one 
 contained      entity-set<br>
                       </td>
                     </tr>
                     <tr>
                       <td valign="top">subtract<br>
                       </td>
                       <td valign="top">all entities in the first entity-set
  minus    any   that occur in the rest<br>
                       </td>
                     </tr>
                                                                        
                                                                
          </tbody>                                                      
                                      
        </table>
               </blockquote>
               <br>
                                                                 
      <p><i>The Group Samples.</i>&nbsp; The samples provide examples of each
  of  these <code>entity-set</code> types.&nbsp; The configuration file ships
   with  7 sample groups, described below. &nbsp;They form the following structure
    (the group key is in parentheses):</p>
                                                                        
    
      <blockquote><code> All LDAP Groups (all)</code><br>
                 <code> &nbsp;&nbsp;&nbsp; Vigdors(1)</code><br>
                 <code> &nbsp;&nbsp;&nbsp; Fracapanes and Ellentucks (2)</code><br>
                 <code> &nbsp;&nbsp;&nbsp; Union test (3)</code><br>
                 <code> &nbsp;&nbsp;&nbsp; Intersection test (4)</code><br>
                 <code> &nbsp;&nbsp;&nbsp; Difference test (5)</code><br>
                 <code> &nbsp;&nbsp;&nbsp; Subtract test (6)<br>
                 </code><br>
                 <code></code></blockquote>
                                                                         
     
      <ul>
                 <li><i> All LDAP Groups (all)</i> contains groups "1" thru 
 "6"   but contains no member entities.&nbsp; It does not (directly) pull 
information   from LDAP.<br>
            <br>
          </li>
                  <li><i> Vigdors (1)</i> contains an <code>entity-set</code>
  with   a <code>filter</code> element whose String value is <code>cn=*vigdor</code>.&nbsp; 
     The members of <i>Vigdors</i> are the entities returned by this query.
          <br>
  <br>
           </li>
                  <li><i>Fracapanes and Ellentucks (2)</i> contains an <code>entity-set</code> 
       with a <code>union</code> element that <i>or's</i> the results of two
       <code>entity-set</code> elements, each of which has a <code>filter 
     </code> element describing an LDAP query.<code>&nbsp;</code> The resulting<code> 
    entity-set</code> contains those entities returned by LDAP from the query
            <code>cn=*fracapane</code> plus those entities returned by <code>cn=*ellentuck</code>.<br>
           <br>
           </li>
                   <li><i> Union test (3)</i> is similar to <i>Fracapanes 
and  Ellentucks      (2)</i> in that it contains an <code>entity-set</code> 
with  a <code>union</code>       element containing 2 <code>entity-sets</code> 
each of which has a <code>filter</code>       element.&nbsp; The resulting 
          <code>entity-set</code> contains the union     of <code>cn=donald 
f*</code> and <code>cn=*frac*</code>. <br>
           <br>
           </li>
                  <li><i> Intersection test (4)</i> contains an <code>entity-set</code>
       with an <code>intersection</code> element that <i>and's</i> the results
     of two <code>entity-set</code> elements, each of which has a <code>filter</code>
  element.&nbsp;      The resulting <code>entity-set</code> contains the
intersection   of           <code>cn=donald f*</code> and <code>cn=*frac*</code>.<br>
           <br>
           </li>
                  <li><i> Difference test (5)</i> contains an <code>entity-set</code>
      with a <code>difference</code> element that <i>exclusive-or's</i> the
   results of two <code>entity-set</code> elements, each of which has a <code>filter</code> 
       element.&nbsp; The resulting <code>entity-set</code> contains the entities
       returned by one but not both of <code>cn=donald f*</code> and <code>cn=*frac*</code>.<br>
           <br>
           </li>
                  <li><i> Subtract test (6)</i> contains an <code>entity-set</code>
     with a <code>subtract</code> element that <i>subtracts</i> the results
    of one <code>entity-set</code> from another.&nbsp; Each <code>entity-set</code>
      has a <code>filter</code> element, and the resulting <code>entity-set</code>
      contains the entities returned by <code>cn=donald f*</code> but not
by        <code>cn=*frac*</code>.<br>
                 </li>
                                                                        
    
      </ul>
                                                                        
    
      <p><i>Limitations of the LDAP Group Store.</i>&nbsp; It is important
    to understand    what the <code>LDAPGroupStore</code> does and does not
  do  and why it does    not support updates.&nbsp; The store queries LDAP
 to discover  entities that   are group members, but it looks at its configuration
   file  to discover groups   and their relationships.&nbsp; As a result,
the   store  will discover an entity   added to LDAP (provided it is returned
 by  an <code>entity-set</code>   defined   in the configuration file.)&nbsp;
  But it will not discover any  group beyond   those defined in the configuration
   file.&nbsp; The way to add a group to  the store is to add a <code>group</code>
element to the configuration document.&nbsp; Likewise,   the way  to make
a group a member of another group    in the store is to add   a <code>group</code>
element to another <code>group</code> element in the configuration document.&nbsp;
   On the other hand, the  way to add an entity   to a group from the store
  is to add or update the entity in LDAP.&nbsp; The  LDAP group store could
  support updates to the group structure (adding or deleting member groups)
  if it had the ability to update the configuration  document.&nbsp; It could
  support updates to entity memberships if it had the ability to update LDAP.&nbsp;
   &nbsp;</p>
                                                                 
      <p><i>Deploying the LDAP Group Store Locally.</i>&nbsp; The configuration
       file as delivered&nbsp;<code></code>points to the Columbia University
   public    LDAP server and defines a few not-terribly-useful groups.&nbsp;
   To implement    a local LDAP group service that uses the <code>LDAPGroupStore</code>,
   modify     the configuration file so that the <code>config</code> element
   points to   your LDAP server.&nbsp; Then, replace the <code>entity-sets
       </code>and    <code>filters</code>   with queries that return meaningful
  results in your    environment. &nbsp;When   you do this, give your groups
  appropriate names    and make sure their keys  are unique.&nbsp;&nbsp;
For   example, you might   convert the structure into  something like:</p>
                                                               
      <blockquote><code> All LDAP Groups (all)</code><br>
                 <code> &nbsp;&nbsp;&nbsp; Faculty Groups (1)</code><br>
                 <code>&nbsp; &nbsp; &nbsp; &nbsp; Biology Department (3)<br>
                &nbsp; &nbsp; &nbsp; &nbsp; Chemistry Department (4)</code><code><br>
               &nbsp; &nbsp; Portal Staff (2)<br>
                 </code><code>&nbsp; &nbsp; &nbsp; &nbsp; Portal Administrators 
   (5)<br>
               &nbsp; &nbsp; &nbsp; &nbsp; Portal Developers (6)</code><code></code><br>
               </blockquote>
               <code></code>                                            
          
      <p>Now un-comment the "ldap" <code>service</code> element  in  <code>compositeGroupServices.xml</code> 
    and start up the portal. &nbsp;In    the <i>Groups Manager</i> channel, 
  try adding <i>All LDAP Groups </i>&nbsp;to    the root group <i>Everyone</i>. 
   &nbsp;(For instructions on using <i>Groups  Manager</i>, see&nbsp;<a
 href="../groupsmanager.html">The Groups Manager Channel</a>.) &nbsp; The 
   groups that you defined in your LDAP configuration file should now be 
 available   for browsing in Groups Manager, although you won't be able to
 update them.        </p>
                                                               
      <p>Once you are comfortable with the process of defining groups in
the configuration    file, you can begin the task of deriving a group structure
    from LDAP that includes    your portal population and models your organization.
   &nbsp;</p>
                                                                        
    
      <h4><a name="Next_Steps"></a>Next Steps</h4>
                                                             
      <p>The process of deploying a composite group service involves (at least)
 the  following steps:</p>
                                                                       
      <ul>
              <li>analyze why you need group information</li>
              <li>identify the necessary sources of group information</li>
              <li>find or create adaptors for these sources</li>
              <li>configure the composite service</li>
                                                               
      </ul>
                                                                       
      <p>Most portals will at least use groups to manage authorization, so
    this   is a common starting point. &nbsp;Many institutions will rely
on   an  LDAP  service as the primary source of group information and supplement
  it  with  information from the portal database. &nbsp;Others may require
 additional   information from human resources, student information or other
 systems. &nbsp;uPortal   currently ships with 2 adaptors, 1 for LDAP (<code>org.jasig.portal.groups.ldap.LDAPGroupStore</code>)
      and 1 for the reference portal database (<code>RDBMEntityGroupStore</code>).
      &nbsp;If you only intend to use these 2 sources, you do not have to
write      a custom group store. &nbsp;If you do need to draw groups from
another   source,   you will have to implement the <code>IGroupStore</code>
and <code>IEntitySearcher</code>      interfaces. &nbsp;You should not have
to write a custom group serivce  (an    <code>IIndividualGroupService</code>)
unless you need to change the  transactional    rules of the service. &nbsp;Of
course, you can always re-implement  or sublcass    the reference implementations
for reasons of efficiency, correctness   or  to add new functions. &nbsp;Please
contribute your code back to the project    so that the entire uPortal community
can benefit from your improvements.    &nbsp;<br>
            </p>
                                                                       
      <p>The final step is to represent your composite group service in the 
configuration file. &nbsp;Describe each top-level service in a <code>service</code> 
element   and designate the default service. &nbsp;Unless you have a
specific reason   for changing it, keep the initial default value of
"local". &nbsp;If a service supports updates, set <code>internally_managed</code>
to <i>true</i>.&nbsp;Note that you must implement the update methods
for such a service in any custom   group store class. &nbsp;Caching of
groups is a must in a  production system.   &nbsp;Either use the portal
Entity Caching Service or implement your own  caching mechanism. &nbsp;
&nbsp;</p>
                                                                       
      <p>Please post your questions, comments, suggestions and ideas to the
      <a href="mailto:jasig-portal@unm.edu">JA-SIG Portal Discussion List</a>. &nbsp;Good luck!     
      </p>
            <i>de 3/4/03</i><br>
               <br>
      <!-- end cut this section to put into jasig table cell format -->
  </BODY>
</HTML>