REAMDE.SECURITY - $Id$

OVERVIEW
--------
The JASIG uPortal security structure is designed to provide a mechanism for
plugging differing security infrastructure drivers into a common framework
with a set of consistent top-level classes, intefaces and method calls. In
addition, the ability to initialize a collection of security context "all
at once" is provided for to allow varying degrees of single signon
functionality with varying degrees of smoke and mirrors. A properties
file is used to store the names of the security contexts to be initialized
within the portal as well as the security provider backends that drive
the logic behind these contexts. This file is consulted when an instance
of "InitalSecurityContext() is created.

InitialSecurityContext() takes a single String parameter that identifies
the root context. For example, if one were to call:

	SecurityContext ctx = new InitialSecurityContext("start");

You should have in your security.properties file a line that looks like:

start=org.jasig.portal.security.provider.SimpleSecurityContextFactory

This would initialize a simple security context for the portal logon.
If you also had lines:

start.xx=org.jasig.portal.security.provider.TrustSecurityContextFactory
start.yy=org.jasig.portal.security.provider.TrustSecurityContextFactory

The call to "new InitialSecurityContext("start") would initialize two
subsidiary security context "xx" and "yy". Each of these in the above
example would be instances of "trust" security contexts (see below).

Each security context can be initialized with different Principals and 
OpaqueCredentials. If you fail to initialize a subcontext, it will inherit
the values of it's parent context. Continuing with the above example,
we could:

	Principal me = ic.getPrincipalInstance();
	me.setUID("newman");

This would assign the Principal object associated with the Security context
to have a UID value of "newman". Note that the method call
getPrincipalInstnace() differs from getPrincipal() in that the former
returns a container to insert information BEFORE authentication. The
latter returns information AFTER authentication. Continuing:

	OpaqueCredentials op = ic.getOpaqueCredentialsInstance();
	op.setCredentials("secret");

Now we can merely:

	ic.authenticate();

This would authenticate to all three of the defined security contexts using
the same UID and credentials. If one needed a different principal, for
instance, PRIOR to authenticate(), we could:

	SecurityContext other = ic.getSubContext("xx");
	Principal otherprinc = other.getPrincipalInstance();
	otherprinc.setUID("oldman");

WHAT SECURITY PROVIDERS ARE INLCUDED?
-------------------------------------

As of this writing we are including three security providers.

The SimpleSecurityContext provider requires a userid and password for
authentication and stores it's credentials in a database table known
as PORTAL_SHADOW that contains two columns USER_NAME and PASSWORD. The
PASSWORD field contains an 8 byte salt value concatenated to a 16 byte MD5
hash value of the salt plus the password. This whole thing is converted
to BASE64 text and has the marker string {MD5} prepended to it to allow
for the potential extension to other hash functions. To populate the
table, a utility program md5passwd is included that will manage the
PORTAL_SHADOW table adding new password records and updating existing
ones. A provision exists in this program to lock records as well.

The PORTAL_SHADOW table in a production environment may have different
access rights than the PORTAL_USERS table that predates it. As
such it is useful NOT to combine them into a single table. Since
the SimpleSecurityContext doesn't access the PASSWORD field in the
PORTAL_USERS table it is probably reasonable to put an historical
placeholder value (an asterisk or exclamation mark) in this field.

The second security provider is the TrustSecurityContext. This is a
trivial security provider that merely takes a UID and marks it as
authenticated without any credentials. The use of this is when the
portal is configured to run behind Web-based BASIC (or CERTIFICATE or
CHALLENGE) authentication and by the time uPortal gets control, the
overarching infrastructure has already performed an authentication. Here
we just take the authenticated principal and introduce it into the
security context.

The third security provider is a little more controversial. The
CacheSecurityContext will actual "authenticate" like the TrustSecurityContext
by merely validating the presence of a Principal in the PORTAL_USERS
database however unlike the other two SecurityContext, this one will
intentionally remember the password claimed to belong to the Principal
and return it with the controversial getCredentials() method that has
been added to a subclassed interface of OpaqueCredentials we call
NotSoOpaqueCredentials. This security context can be useful for certain
types of sleight-of-hand single-signon emulation but comes with some
security risks a few of which are discussed in the JavaDoc that is
associated with the CacheSecurityContext class.
