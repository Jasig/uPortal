<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="Generator" content="Microsoft Word 97">
   <meta name="GENERATOR" content="Mozilla/4.75 [en] (WinNT; U) [Netscape]">
   <title>Writing a channel for the uPortal(tm)</title>
</head>
<body>
&nbsp;
<table CELLSPACING=0 CELLPADDING=0 >
<tr>
<td WIDTH="20"></td>

<td VALIGN=TOP WIDTH="640">
<h2>
Writing a Channel for the uPortal(tm)</h2>
by Michael Oltz, Cornell University
<p>FIRST DRAFT -- last revised 2000/10/08 18:01 EDT&nbsp;
<br>&nbsp;
<p>I recommend that you start by reading "What is XML and why use it?"
and "What and why is XSLT?". Both of them contribute to an overview of
what is involved in developing for the JA-Sig uPortal(tm), and will give
you an idea of whether you want to read the whole rest of the document
or what parts.
<br>&nbsp;
<p><a href="#XML">What is XML and why use it?</a>
<p><a href="#decide_info">Decide what information you want to show</a>
<p><a href="#decide_represent">Decide how to represent the information
as XML</a>
<p><a href="#writing_DTD">Writing a DTD</a>
<blockquote><a href="#DTD_elements">DTD ELEMENTs</a>
<p><a href="#DTD_attlists">DTD ATTLISTs</a></blockquote>
<a href="#writing_Java">Writing the Java code</a>
<p><a href="#userid">How to get the Userid</a>
<p><a href="#output_XML">How to output your XML</a>
<p><a href="#XSLT">What and why is XSLT?</a>
<p><a href="#XSLT_works">How XSLT works</a>
<p><a href="#Location">Location specifiers for matches and selects</a>
<p><a href="#XSLT_commands">Some of the most useful XSLT commands</a>
<p><a href="#files">What to name your files and where to put them</a>
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<h3>
<a NAME="XML"></a>What is XML and why use it?</h3>
The official 2.0 release of the JA-Sig uPortal(tm) software will support
an XML architecture for&nbsp; channels. This document will discuss how
to write an XML channel in the 1.0 software environment, because 2.0 is
not sufficiently complete as yet. Much of the information will be the same
for 2.0.
<p>XML is a standard for information markup, which describes <i>what</i>
the information <i>is</i>, rather than what it <i>looks</i> like on the
screen (the latter is what HTML does). The reason that the uPortal uses
XML, is that it allows your Java code to postpone until a later step, worrying
about what kind of output display the user has. At that later step, you
could, for example, format for a high-resolution desktop computer screen,
a low-resolution desktop computer screen, a handheld windowing computer,
or even a palmtop.
<dl>The example provided with the uPortal code is the <font face="Courier New,Courier"><font size=-1>org.jasig.portal.xmlchannels.CBookmarks
</font></font>class.
The demonstration bookmarks channel stores its data in a relational database
table, and the table entry for each user contains an XML tree as a string<font face="Arial">.
</font>The
bookmarks channel stores its information as XML, and happens to use DOM
to parse that XML, or to alter it. You do not have to store your data that
way; XML is <i>required</i> only when you are sending information to be
displayed to the user, and you can generate that XML any way you want.
<p>Here are the files related to the CBookmarks class:
<br><font face="Courier New,Courier"><font size=-1><a href="CBookmarks.java">org.jasig.portal.xmlchannels.CBookmarks.java</a></font></font>
<br><a href="bookmarks.dtd">bookmarks.dtd</a>
<br><a href="BookmarksChannel.ssl">BookmarksChannel.ssl</a>
<br><a href="edit_regular.xsl">edit_regular.xsl</a>
<br><a href="editBookmark_regular.xsl">editBookmark_regular.xsl</a>
<br><a href="view_regular.xsl">view_regular.xsl</a></dl>
The steps involved in creating a channel are:
<p>1. Decide what information you want to show in your portal window.
<p>2. Decide how to represent the information as XML.
<p>3. Optionally, write a DTD (Document Type Definition) which describes
that XML.
<p>4. Write your Java code. It should extend the <tt>GenericPortalBean</tt>
class, and implement the <tt>IXMLChannel</tt> interface. Output the information
you want to display in your channel window, as XML.
<p>5. Write one or more XSLT stylesheets to transform the XML that your
code will output, into HTML to display on the particular display device
used by the user. At first you can write just one of these, and customize
it for various output devices later.
<br>&nbsp;
<p>Now I'll go into more detail for each of these steps.
<br>&nbsp;
<h3>
<a NAME="decide_info"></a>Decide what information you want to show</h3>
The primary thing to keep in mind here, is to keep it simple. A portal
channel generally has to share the browser window with several other things,
and you may not be allocated very much horizontal space. If the browser
column you are in is narrow, and you put too much information in your window,
it will elongate vertically and may push part of itself or of other channel
windows below the bottom of the screen.&nbsp;
<p>One way around this is to break up your information into several small
portions, and switch between them with buttons. The bookmarks channel shows
how to do this in its bookmark-editing mode; see the "setRuntimeData" method
and the bookmarks.ssl stylesheet.
<br>&nbsp;
<h3>
<a NAME="decide_represent"></a>Decide how to represent the information
as XML</h3>
XML looks something like HTML, but you get to name the tags yourself --
in XML the tags are called "elements" -- and decide what they mean. You
can decide what their attributes are if any (attributes are the equal-sign
things inside an element). You can decide what contents an element may
enclose, or decide that the element never has any contents. In HTML, &lt;br>&lt;/br>
is an example of an element that never has any contents.
<p>An important difference between XML and HTML is that XML parsers are
much fussier about syntax. In an HTML document, if there is a missing end
tag, the browser will try to make a guess at what was intended. In XML,
the syntax is crucial to indicating the meaning of each morsel of data,
so far less latitude can be allowed.
<p>Here is an example of what XML looks like. Suppose you want to write
an XML description of an hourly employee's timecards. The resulting XML
might look like this. I've left out some details and put in ellipses.
<p><tt>&lt;?xml version="1.0"?></tt>
<br><tt>&lt;!DOCTYPE timecards SYSTEM "http://amachine.somewhere.edu/dtd/timecards.dtd"></tt>
<br><tt>&lt;timecards employee="John J. J. Smith"></tt>
<br><tt>&lt;timecard payperiod="12" startdate="08/07/2000" enddate="08/18/2000"></tt>
<br><tt>&lt;day date="08/07/2000" dow="Wednesday"></tt>
<br><tt>&lt;worktime start="07:52" end="12:03" /></tt>
<br><tt>&lt;worktime start="12:47" end="16:30" /></tt>
<br><tt>&lt;worktime start="20:19" end="22:48" comment="overtime fixing
pipe break" /></tt>
<br><tt>&lt;/day></tt>
<br><tt>&lt;day date="08/08/2000" dow="Thursday"></tt>
<br><tt>...</tt>
<br><tt>&lt;/day></tt>
<br><tt>&lt;/timecard></tt>
<br><tt>&lt;timecard payperiod="13" ... ></tt>
<br><tt>...</tt>
<br><tt>&lt;/timecard></tt>
<br><tt>&lt;/timecards></tt>
<p>The first line says that this document conforms to the XML 1.0 standard;
yes, the question marks have to be there. The second line tells what the
name of this document type is, and where the DTD is that describes the
syntax of the elements in it. As you can see, the syntax of the rest of
the document closely resembles HTML. One thing to remember, is that after
the two header elements (<tt>?xml</tt> and <tt>!DOCTYPE</tt>) XML requires
that you have <i>one</i> element that encloses <i>everything</i> else.
This is called the <i>document element</i>. In the example above this is
the <tt>&lt;timecards></tt> element.
<p>Keep in mind that you can put anything inside an element that you want,
providing that you describe the syntax of the contents in the DTD. Some
elements may contain nothing; others might contain one or more of one other
different element (like the <tt>&lt;timecard></tt><font face="Arial"> </font>elements
inside the <tt>&lt;timecards></tt> element). Some elements may contain
a variety of different elements one after the other. And some kinds of
element may have contents that are free-form text, rather than any specific
XML element.
<p>One question you may have when designing your XML is, when you have
some text associated with an element, should it be an attribute of the
element, like this:
<p><tt>&lt;orderitem prodnum=12345 quantity=2 comment="Do not backorder"
/></tt>
<p>or should it be the contents of the element, like this:
<p><tt>&lt;orderitem prodnum=12345 quantity=2></tt>
<br><tt>Do not backorder.</tt>
<br><tt>&lt;/orderitem></tt>
<p>I suggest this criterion. If the datum is an integer or floating point
number, or an always relatively short text string without any internal
formatting; there are only one or a small, fixed quantity of such values
associated with a particular element; and the datum always has the same
interpretation; then use attributes, as in our first <tt>&lt;orderitem>
</tt>example.
If the datum is an arbitrary-length text string, or has formatting markup
in it, but the text string always has the same relationship to the element,
then make it the contents of the element, as in the second <tt>&lt;orderitem>
</tt>example
above. If there are an arbitrary number of sub-data to represent, or if
the meaning of their relationship to the parent element can vary, then
define a new element to contain them; such as the way we are using <tt>&lt;worktime>
</tt>elements
inside the <tt>&lt;day> </tt>element in our <tt>&lt;timecards></tt> example.
<br>&nbsp;
<br>&nbsp;
<h3>
<a NAME="writing_DTD"></a>Writing a DTD</h3>
HTML, XML, and certain other document formats, are descended from SGML,
Standard Generalized Markup Language. It is SGML which specifies the use
of angle brackets &lt; >, opening and closing tags, the syntax of incorporating
attributes, and other overall aspects of what these other document formats
look like. For each kind of document derived from SGML, a Document Type
Definition (DTD) is written to describe the <i>particular</i> elements
and attributes used for that kind of document. For example, there is a
DTD at www.w3.org describing each release level of HTML.
<p>There are two levels of strictness when parsing XML. "Well-formedness"
merely asks whether the angle brackets &lt; > and quotes are properly matched,
whether each opening tag has a properly nested closing tag, and other non-specific
tests. "Validation" parsing compares the XML against the specific DTD which
defines its syntax. The uPortal uses a parser that only requires "well-formedness".
So, you do not <i>have</i> to write a DTD if you do not want to. The information
here is for those who are going to use the same XML format for some other
purpose that requires a DTD, or for those who want to write a DTD anyway.
<p>A DTD itself does not have any kind of header&nbsp; information, or
enclosing element (like <tt>&lt;HTML></tt> or <tt>&lt;BODY></tt> on a web
page). It simply contains definitions of four different kinds of things,
plus any comments and white space you want to add. The four kinds of things
are ENTITYs, ELEMENTs, ATTLISTs, and NOTATIONS. You can also conditionally
include sections of the DTD using the INCLUDE and IGNORE statements. For
the kind of use we will be making of XML, it is likely that all you will
need are ELEMENTs and ATTLISTs, so that's all we will describe here.
<br>&nbsp;
<h4>
<a NAME="DTD_elements"></a>DTD ELEMENTs</h4>
An ELEMENT declaration describes an element that can be included in your
XML document. The ELEMENT declaration does <i>not</i> describe the attributes
that can be specified in the opening tag of the element; that's what ATTLIST
is for, and we'll describe it later. The two simplest kinds of ELEMENT
are:
<p><tt>&lt;!ELEMENT whatevername EMPTY></tt>
<p><tt>&lt;!ELEMENT someothername ANY></tt>
<p>Note that to distinguish them from ordinary document tags, DTD declarations
begin with an angle bracket <i>and</i> an exclamation point. EMPTY means
that there cannot be anything at all enclosed between the opening and closing
tags of the element -- but there can be attributes in the opening tag.
There are two ways to write an empty element in your XML document:
<p><tt>&lt;whatevername>&lt;/whatevername></tt>
<p><tt>&lt;whatevername/></tt>
<p>In either case, the opening tag can have attributes; and the slash character
must be right next to the angle bracket without any space.
<p>ANY means that the element can enclose any well-formed information between
its opening and closing tag; no validation will be performed on the contents.
<p>The more complicated but far more useful ELEMENT type has as its third
part a <i>content model</i>. A content model is a thing in parentheses
that tells what other elements, and perhaps some text, that the element
you are defining can enclose between its opening and closing tags. The
most straightforward example is:
<p><tt>&lt;!ELEMENT aplainone (whatevername) ></tt>
<p>This means that element <tt>aplainone</tt> must enclose exactly one
instance of the <tt>whatevername</tt> element, and nothing else. That inner
element can itself be defined to have some content. But in this example,
I show the inner element as empty:
<p><tt>&lt;aplainone></tt>
<br><tt>&nbsp;&nbsp;&nbsp; &lt;whatevername/></tt>
<br><tt>&lt;/aplainone></tt>
<p>Since we may want our enclosed material to be rather more complex, there
are some operators that can be added to make more complicated content models.
<br>&nbsp;
<table BORDER WIDTH="80%" >
<tr>
<td>,&nbsp;</td>

<td>(comma) the elements must appear in the exact order shown</td>
</tr>

<tr>
<td>|</td>

<td>(vertical bar) choose one of the elements listed</td>
</tr>

<tr>
<td>?</td>

<td>The element may be left out, or appear exactly once</td>
</tr>

<tr>
<td>*</td>

<td>The element may be left out, or appear one or more times</td>
</tr>

<tr>
<td>+</td>

<td>The element must be present, and may appear one or more times</td>
</tr>
</table>

<p>The first two operators, the comma and vertical bar, appear in between
a list of elements. The last three operators, ?, *, and +, each appear
at the very end of the name of the element, or parenthesized group, to
which they apply. If none of the latter three is specified for a particular
element in the content model, then that element must appear and it must
appear exactly once in the position shown.
<p><tt>&lt;!ELEMENT cuperson (student, (faculty | staff) ) ></tt>
<p>This means "a cuperson element encloses exactly one student element
followed by either exactly one faculty element or exactly one staff element."
(I don't guarantee that these examples make practical sense; they are contrived).
So either one of these would be permitted (assuming that some of the elements
have attributes):
<p><tt>&lt;cuperson></tt>
<br><tt>&nbsp;&nbsp; &lt;student name="Humbert A. Lerner"/></tt>
<br><tt>&nbsp;&nbsp; &lt;faculty name="Phil O. Soffer"/></tt>
<br><tt>&lt;/cuperson></tt>
<p><tt>&lt;cuperson></tt>
<br><tt>&nbsp;&nbsp; &lt;student name="Elaine Change"/></tt>
<br><tt>&nbsp;&nbsp; &lt;staff name="Ingrid Able"/></tt>
<br><tt>&lt;/cuperson></tt>
<p>The following example illustrates using the "how many" operators:
<p><tt>&lt;!ELEMENT oddthing (tool?, vehicle*, toy+) ></tt>
<p>"An oddthing consists of either no or exactly one tool element, followed
by no or any number of vehicle elements, followed by one or more toy elements."
<p>The other kind of thing you can put in an ELEMENT is <tt>#PCDATA</tt>,
which means "arbitrary unparsed text". The XML standard requires that if
the <tt>#PCDATA</tt> token is present in the content model, it must always
be listed there first. Depending on the nature of the model, this does
<i>not</i>
necessarily mean that the text to which it may refer, must appear first
inside the XML element in the documents being described. Here is an example
of that:
<p><tt>&lt;!ELEMENT something (#PCDATA | shape)+ ></tt>
<p>The something element must enclose one or more things, each of which
may be either #PCDATA or a shape. So the first of the things can be of
either kind.
<br>&nbsp;
<h4>
<a NAME="DTD_attlists"></a>DTD ATTLISTs</h4>
Now that we can define the elements that can appear in our XML, how do
we define the attributes that can be specified inside their opening tags?
That is the purpose of the ATTLIST definition. Each occurrence of ATTLIST
describes <i>one</i> attribute of <i>one</i> element. Usually an ELEMENT
appears first, followed by a series of ATTLISTs for that element. In each
ATTLIST specification, the !ATTLIST keyword is followed by the name of
the element whose attribute this is; the name of the attribute; the kind
of information represented by the attribute's value; and finally a keyword
that indicates how "required" the attribute is, plus optionally a default
value.
<p>The keywords for the "how required" part are these:
<br>&nbsp;
<table BORDER WIDTH="100%" >
<tr>
<td>#REQUIRED</td>

<td>The attribute always must be specified on the element. If it's missing
that's an error.</td>
</tr>

<tr>
<td>#IMPLIED</td>

<td>The attribute may be missing (and there is no default), or may appear
with any value.</td>
</tr>

<tr>
<td>#FIXED plus default value</td>

<td>If the attribute is specified then it must have the default value given;
if it's not there the default will be assumed.</td>
</tr>

<tr>
<td>Default value only</td>

<td>If the attribute is specified then it can have any value; if it's not
given it will assume the default.</td>
</tr>
</table>

<p>Although there are several different kinds of information that can appear
in the value of an attribute, the most basic one is CDATA, which again
means "arbitrary unparsed text." We'll illustrate in a moment how to specify
an enumerated value.
<p><tt>&lt;!ATTLIST student name CDATA #REQUIRED></tt>
<p>This says that the student element has an attribute called "name" which
has a character value and which must always be specified.
<p><tt>&lt;!ATTLIST student hometown CDATA "none specified"></tt>
<p>This says that the student element has an attribute called "hometown"
which has a character value. If the hometown attribute actually appears
in the element it can have any value; if it does not appear then the value
for that student will be "none specified".
<p>An enumerated value for an attribute, looks a little bit like a content
model, but the only operator it can have in it is the vertical bar for
choice.
<p><tt>&lt;!ATTLIST student college (arts | agr | hotel | law | vet | humec
| ilr | engr) #REQUIRED ></tt>
<p>This means that the student element has an attribute called "college"
which must be present, and which must have exactly one of the listed, and
only of the listed, values.
<br>&nbsp;
<br>&nbsp;
<h3>
<a NAME="writing_Java"></a>Writing the Java code</h3>
Your Java class should be declared like this:
<p><tt>public class CTimecards extends GenericPortalBean implements IXMLChannel</tt>
<p>The class <tt><a href="GenericPortalBean.java">GenericPortalBean</a></tt>
contains only three methods. Generally the base class implementation of
them will be fine for your needs. The <tt>setPortalBaseDir
</tt>method
will store a string inside the current object, that remembers the base
directory of the uPortal install tree. The uPortal framewok will call that
method for you with the correct value, so you can assume it has been set.
You can call <tt>getPortalBaseDir</tt> to get that base directory string.
The uPortal software refers to several files in the "source" or "webpages"
subdirectories of the installation; that way, there is no need to store
these pages in the web server's web pages root, since client machines do
not need to access them directly. The third method in <tt>GenericPortalBean</tt>
is <tt>debug</tt>, which puts a string message to <tt>System.out</tt>.&nbsp;
<p>The <tt><a href="IXMLChannel.java">IXMLChannel</a></tt> interface describes
the methods you need to implement to be a channel.&nbsp;
<p><tt>getSubscriptionProperties()</tt> is a "beanish" kind of call. The
uPortal will call this method, and your code should create, initialize,
and return an instance of the class <tt><a href="ChannelSubscriptionProperties.java">ChannelSubscriptionProperties</a></tt>.
The latter class contains generic characteristics of your channel: what
is the user-visible name of the channel? What buttons should be shown in
its title bar (minimize, close, edit)? Does the channel have a help screen?
Can the the channel be "torn off" as a new browser window (I don't think
this is implemented yet)?
<p>The uPortal will call the <tt>getRuntimeProperties()</tt> method immediately
before requesting the channel to render itself. Your channel class should
create, initialize and return an object of the class <tt><a href="ChannelRuntimeProperties.java">ChannelRuntimeProperties</a></tt>.&nbsp;
At present the only thing inside this class is an indicator of whether
the channel is presently capable of rendering itself at all. If you set
this indicator to false (it is by default true), the uPortal will not bother
to ask your channel to render itself.
<p><tt>setStaticData()</tt> is used by the uPortal to pass in a reference
to a <tt><a href="ChannelStaticData.java">ChannelStaticData</a></tt> object
that the uPortal has created for you. The uPortal will call this method
when the channel is being created.
<tt>ChannelStaticData</tt> contains
a channel ID number that is unique within the user's session, and any channel
configuration parameters that come from the channel's properties file.
<p>The uPortal will call <tt>setRuntimeData()</tt> just before each time
it calls
<br>renderXML. It will pass in an instance of <tt><a href="ChannelRuntimeData.java">ChannelRuntimeData</a></tt>.
The two
<br>important things in that class are the <tt>baseActionURL</tt>, which
is the full filepath to the .jsp file that caused your channel to get called
(normally it's "layout.jsp");
<br>and a reference to the <tt>HttpServletRequest</tt> object for the current
<br>request. You can also call the <tt>getParameter </tt>method of your<tt>
ChannelRuntimeData </tt>object to get at any parameters that are sent in
to your channel (for example, from someone filling out any form blanks
you may have put up).
<p>One of the two methods in which "something actually happens" is <tt>receiveEvent.</tt>
This method is called whenever the user clicks on a control (that the uPortal
knows about) that affects your channel; for example the minimize, full-screen/restore,
close, and edit buttons in the channel's title bar. An object of the class
<tt><a href="LayoutEvent.java">LayoutEvent</a></tt>
is passed in to this method, and you can call <tt>getEventNumber</tt> or
<tt>getEventName</tt>of
that class to find out which control was clicked, then react to it.
<p>The most important method of the <tt>IXMLChannel</tt> interface in which
"something actually happens" is <tt>renderXML</tt>. The uPortal calls <tt>renderXML</tt>
when it wants your channel to "draw" itself. As mentioned earlier, your
Java code should just
<br>generate and output some XML containing the information you want to
display, and the stylesheet(s) you write will take that XML and turn it
into HTML to be sent to the client. If you want to, you can internally
keep track of some kind of "state" of your channel, and generate different
XML streams depending on the state. This is what the bookmarks channel
does.
<br>&nbsp;
<br>&nbsp;
<h3>
<a NAME="userid"></a>How to get the Userid</h3>
The userid is accessible from the <tt>javax.servlet.http.HttpServletRequest
</tt>object<tt>.</tt>
In a uPortal channel, you can get at that object via <tt>ChannelRuntimeData</tt>
(see the <tt>setRuntimeData</tt> method above). Assuming you have stored
your <tt>ChannelRuntimeData</tt> object reference in a field called <tt>runtimeData</tt>,
you can do this to get the userid:
<p><tt>String theUserid = runtimeData.getHttpRequest().getRemoteUser();</tt>
<p>At Cornell, provided that the web server has been modified to do Sidecar
<br>authentication on the uPortal pages, this userid will be the Cornell
NetID,
<br><i>or</i> it will be "guest" for people who do not have Sidecar or
are not running it. Normally, Cornell channels providing NetID-specific
user information are <i>not</i> made available to the "guest" userid by
the local uPortal site manager. If you wish to make a demonstration version
of your channel available, you could check for that userid in your channel
and provide dummy demonstration data or operate in a limited manner.&nbsp;
<br>&nbsp;
<br>&nbsp;
<h3>
<a NAME="output_XML"></a>How to output your XML</h3>
In your <tt>renderXML</tt> method (see the <b>Writing the Java code</b>
section above), you need to get your channel's data, turn it into XML,
then hand it over to a method of the <tt>XSLTProcessor</tt> class to get
it formatted. The problem with using the CBookmarks channel as an example,
is that it
<i>stores</i> its data in XML format already, so when it comes
time to render, all it does is run a stylesheet on the XML to turn it into
HTML. Since our data is coming from non-XML databases, we must first <i>make</i>
some XML.
<p>Since the processing method you must call can (indirectly) accept a
byte stream or character stream, the most straightforward way to make your
XML is to concatenate it together as a <tt>String</tt> or <tt>StringBuffer</tt>.
Then convert the <tt>String</tt> to a byte stream (an <tt>InputStream</tt>)
or a character stream (a <tt>Reader</tt>), put it into an <tt>XSLTInputSource</tt>,
and call the processor.
<p>The
<tt>renderXML</tt> method is passed a SAX <tt>DocumentHandler</tt>
object as a parameter. The purpose of that DocumentHandler is to receive
the completely formatted HTML to be sent to the browser. When you call
the <tt>XSLTProcessor</tt>, you pass in the <tt>DocumentHandler</tt> object
as the output destination.
<p>Here's an example from the <tt>CBookmarks</tt> channel, with an added
data creation section.
<p><tt>public void renderXML(DocumentHandler out)</tt>
<br><tt>{</tt>
<br><tt>&nbsp; String myData;</tt>
<br><tt>&nbsp; myData = "&lt;?xml version \"1.0\"?>" +</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; "&lt;!DOCTYPE bookmarks SYSTEM " +&nbsp;</tt>
<br><tt>&nbsp; "\"http://localhost:8000/my/testportal/dtd/bookmarks.dtd\">"
+</tt>
<br><tt>&nbsp; "&lt;bookmarks>" +&nbsp;</tt>
<br><tt>&nbsp; "&lt;bookmark url=\"http://yahoo.com\" name=\"Yahoo\" "
+&nbsp;</tt>
<br><tt>&nbsp; "comments=\"Search engine\"/>" +</tt>
<br><tt>&nbsp; "&lt;/bookmarks>";</tt>
<p><tt>&nbsp; StringReader myDataSR = new StringReader(myData);</tt>
<p><tt>&nbsp; try {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if (set!=null) {</tt>
<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; XSLTInputSource&nbsp;
stylesheet = set.getStylesheet(&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
runtimeData.getHttpRequest() );</tt>
<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(stylesheet!=null)
{</tt>
<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
XSLTProcessor processor =&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
XSLTProcessorFactory.getProcessor();</tt>
<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
processor.process(new XSLTInputSource(myDataSR),&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
stylesheet,new XSLTResultTarget(out));</tt>
<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; } catch (Exception e) {};</tt>
<br><tt>}</tt>
<p>The <tt>!DOCTYPE </tt>element has as its second token the name of the
root element of the XML document; then the word <tt>SYSTEM</tt> in capitals;
then a URL in quotes for the document type definition of your XML format.
This is followed by the actual XML content of your channel. After making
this string, the example turns it into a <tt>StringReader</tt> for the
benefit of <tt>XSLTInputSource</tt> (see later in the example).
<p>In the real <tt>CBookmarks</tt> class, the entire XML document, headers
and all, would come from a file or a database, rather than being hard-coded
as the value of the <tt>myData</tt> string. At Cornell, we would be getting
information from a database via CUObjects, and turning that into an XML
string.
<p>The <tt>try</tt> clause contains the code that runs your XML through
a stylesheet to the output. The clause as shown here, does three things.
First, it finds the stylesheet you want to use to transform your XML. The
"<tt>set</tt>" object is initialized in the constructor; it keeps a list
of the XML stylesheet(s) you have created for this channel.&nbsp; Secondly,
the <tt>try</tt> clause makes an <tt>XSLTProcessor</tt> via the factory
method. Thirdly, it calls the <tt>process </tt>method of the <tt>XSLTProcessor</tt>.
The three arguments are: (1) an <tt>XSLTInputSource</tt>, which is just
a wrapper for several different kinds of input you can use. This first
one, wraps the XML input document. (2) another <tt>XSLTInputSource</tt>
wrapping your stylesheet. (3) an <tt>XSLTResultTarget</tt> wrapping the
destination for the output from the XSLT stylesheet. In this case we use
as our destination the <tt>out</tt> object which was passed in as a parameter
to the <tt>renderXML</tt> method.
<br>&nbsp;
<br>&nbsp;
<h3>
<a NAME="XSLT"></a>What and why is XSLT?</h3>
XSLT stands for eXtensible Stylesheet Language: Transformations. Its purpose
is to transform, or modify, an XML document. An XSLT stylesheet is itself
an XML document; it uses a set of XML elements defined by the "xsl:" namespace
prefix.&nbsp;
<p>A question that may come to mind immediately is -- why not just write
a Java program to transform the XML? One reason to have a specific language
for XML transformations, is that it can be more concise than a hand-coded
Java program. Another is that it can be declarative -- instead of being
organized as a procedural or object-oriented program as such, you can write
a description of the information you want to transform, and the result
you want to achieve, and let XSLT take care of the functionality that gets
you what you want. A third motivation for creating XSLT, and making it
look like XML, was the earlier example of HTML and CSS -- the stylesheets
do not use the same syntax as the things they are formatting, and this
is frustrating.
<p>If one looks at the code for a uPortal channel (in 1.0 anyway), it eventually
becomes evident that it is not <i>absolutely</i> necessary to use XSLT.
One could theoretically output HTML directly. However, the side effect
is that one loses the flexibility to customize the output for whatever
display device the end user is using.
<p>Sites that find it too demanding to expect every developer to learn
XSLT, could specialize the work. Most developers would only have to learn
a little about XML (as much as in this document's section on XML), and
know enough HTML to define what they want the output to look like. Then
the developer has to write the Java code to read their data and output
it to the XML they have defined. The developer would give an example of
what their XML will be, and of what the HTML needs to be, to a web specialist.
The specialist would write the DTD for the XML, and write the required
XSLT stylesheet(s). Another way to divide up the work, is for one person
to do all the "web" part -- XML, XSLT, and HTML -- and provide the XML
specification to the Java developer.
<br>&nbsp;
<br>&nbsp;
<h3>
<a NAME="XSLT_works"></a>How XSLT works</h3>
There are several patterns that could be used for writing XSLT. If you
are generating XML in your bean for your channel, and can arrange it however
you like to suit the needs of the output, then the declarative style mentioned
above, in which one describes the inputs one might find, and the output
one wishes to generate as a result, will be able to accommodate your development.
This is the only pattern we will describe here, and we will leave out considerable
detail. For more information, consult the <a href="http://www.w3.org/TR/xslt">XSLT
recommendation</a>, or the book <i>XSLT Programmer's Reference</i> by Michael
Kay (Wrox Press, 1-861003-12-9). At this writing it is the only book whose
sole subject is XSLT.
<p>An XSLT program written in the most declarative style, consists primarily
of a series of <i>templates</i>. Each template describes a pattern of one
or more nodes in the source XML document to search for. The template also
describes the information to be output when a match is found.
<p>In our earlier section on representing information as XML, we said that
in an XML document there must be one element that encloses all other elements,
and this is called the document element. When an XML document is being
parsed or processed, it is conceptually considered to be a tree data structure,
with everything in the tree, including the document element, being underneath
an invisible parent node called the <i>document root</i>. So, in a well-formed
XML document, the (invisible) document root will have one child, the (visible)
document element, and everything else will be hanging off the document
element.
<p>In XSLT, after the XML source document has been read in and parsed,
and certain preparatory steps have been taken, the actual transformation
of the document begins by "processing the document root." How do you "process"
a node in the XML tree? It works like this:
<p>1. Search the XSLT templates looking for one that matches the node.
<p>2. If a matching template is found, look at the contents of the template;
if there are any XSLT instructions in there, execute them; send out everything
else inside the template to the output document. When done with this step,
you are done processing the node.
<p>3. If <i>no</i> matching template was found, then run the "built-in
template," that is, do the default action. The default action is, "process
all the children of this node." And that means, to run this <i>entire</i>
algorithm on <i>every</i> immediate child of this node, whether or not
any match is found for any one of them.
<br>&nbsp;
<p>To rephrase and amplify: If no matching template can be found for a
node being processed, then the immediate children of that node will be
recursively processed, and the process will continue downward until a match
is found along every branch <i>or</i> the leaves are arrived at. If a matching
template is found for a node being processed, then the immediate children
of that node will
<i>not</i> be processed -- unless there is an XSLT instruction
inside the matching template that explicitly causes further processing.
<p>Let me give a few very simple examples.
<p><tt>&lt;xsl:stylesheet</tt>
<br><tt>&nbsp;&nbsp;&nbsp; xmlns:xsl="http://www.w3.org/1999/XSL/Transform"</tt>
<br><tt>&nbsp;&nbsp;&nbsp; version="1.0"></tt>
<br><tt>&lt;xsl:template match="/"></tt>
<br><tt>&nbsp; &lt;html></tt>
<br><tt>&nbsp; &lt;head></tt>
<br><tt>&nbsp; &lt;/head></tt>
<br><tt>&nbsp; &lt;body></tt>
<br><tt>&nbsp; &lt;/body></tt>
<br><tt>&nbsp; &lt;/html></tt>
<br><tt>&lt;/xsl:template></tt>
<br><tt>&lt;/xsl:stylesheet></tt>
<p>The first element identifies this document as an XSL stylesheet. It
defines a namespace, giving its prefix as "xsl" and its URI as "http://www.w3.org/1999/XSL/Transform".
It also gives the XML version as 1.0. Normally you should just copy this
element verbatim at the beginning of your own stylesheet.
<p>The <tt>xsl:template </tt>element says that it matches the (invisible)
document root; that's what the <tt>match="/"</tt> means. We'll talk more
about specifying matches in the next section. The template then proceeds
to output a completely empty but syntactically legal HTML page, with no
title and no contents. Because there are no XSLT statements inside the
template to cause further matching, the XSLT processor does not look any
further inside the input XML document. Rather a useless example, but it's
a start.
<p><tt>&lt;xsl:stylesheet</tt>
<br><tt>&nbsp;&nbsp;&nbsp; xmlns:xsl="http://www.w3.org/1999/XSL/Transform"</tt>
<br><tt>&nbsp;&nbsp;&nbsp; version="1.0"></tt>
<p><tt>&lt;xsl:template match="/"></tt>
<br><tt>&nbsp; &lt;html>&lt;head>&lt;/head>&lt;body></tt>
<br><tt>&nbsp; &lt;xsl:apply-templates></tt>
<br><tt>&nbsp; &lt;/body></tt>
<br><tt>&nbsp; &lt;/html></tt>
<br><tt>&lt;/xsl:template></tt>
<p><tt>&lt;xsl:template match="timecard"></tt>
<br><tt>&nbsp;&nbsp; ... &lt;!-- details omitted -- presumably output some
stuff --></tt>
<br><tt>&lt;xsl:template></tt>
<p><tt>&lt;/xsl:stylesheet></tt>
<p>Let's assume that we are running this stylesheet on the "timecards"
example we gave back in the section on representing data as XML. In the
template that matches the document root, the above example outputs the
beginning information of an HTML page. Then we encounter something new.
Remember that if a node is matched, the processing will not descend to
any children of the current node unless you tell it to. The <tt>xsl:apply-templates
</tt>element
is one way, perhaps the simplest way, to say that you want to go deeper
down the tree. Because no additional details are given in this example
of it, it will process all the children of the current node, looking for
any matching templates. When it is done processing all of them, it will
pop back up into this template, and will carry out the rest of this template's
contents. In this example, that means it will output two HTML instructions
which close the body of the HTML page, then close the page itself.
<p>Ah, but what happens while the <tt>xsl:apply-templates</tt> is being
obeyed? It will begin by looking at the descendant of the document root;
that would be the visible document element. In our "timecards" XML document,
the document element is <tt>&lt;timecards></tt>, but there is no match
for that (a node match is a "whole word" match, not a substring match).
So it will follow the default advice of the built-in template, and look
at every one of the immediate children of <tt>&lt;timecards></tt>. Well,
in our earlier example they are all instances of <tt>&lt;timecard></tt>,
and there <i>is</i> a match for that. So, for each one, the XSLT processor
will run the contents of the last template in our example just above. I
haven't bothered to specify exactly what happens there.
<br>&nbsp;
<br>&nbsp;
<h3>
<a NAME="Location"></a>Location specifiers for matches and selects</h3>
In XSLT, you need to be able to specify what node or nodes in the XML input
tree you want to refer to. This is done with the "match" attribute on <tt>xsl:template</tt>,
and with the "select" attribute on commands such as <tt>xsl:value-of</tt>.
<p>XSLT uses <a href="http://www.w3.org/TR/xpath">the XPath specification</a>
to define how to make such references. There is both a detailed and an
abbreviated way of writing the references, and we will cover only the abbreviated
way. These examples are extracted and modified from Section 2.5 "Abbreviated
Syntax" of the XPath specification, and cover only a few combinations that
you are most likely to need. The phrase "context node" means "the node
from the perspective of which you want to 'move' as a starting point."
The examples are in the following format.
<p><tt>timecard</tt>
<blockquote>is all of the immediate children of the context node which
are elements named 'timecard'</blockquote>
This means that if the string "<tt>timecard</tt>" appears in a match attribute
such as
<br><tt>&lt;xsl:template match="timecard"></tt>
<br>or a select attribute such as
<br><tt>&lt;xsl:value-of select="timecard"></tt>
<br>then it would be interpreted as described above.
<p><tt>*</tt>
<blockquote>is all of the children of the context node which are elements,
no matter which kind of element they are</blockquote>
<tt>.</tt>
<blockquote>is the context node itself</blockquote>

<p><br><tt>text()&nbsp;</tt>
<blockquote>is all children of the context node which are text nodes rather
than element nodes</blockquote>
<tt>timecard[1]</tt>
<blockquote>is the first 'timecard' child of the context node</blockquote>
<tt>timecard[last()]</tt>
<blockquote>is the last 'timecard' child of the context node</blockquote>
<tt>*/timecard</tt>
<blockquote>is all the grandchildren of the context node that are elements
named 'timecard'</blockquote>
<tt>@payperiod</tt>
<blockquote>is the attribute named 'payperiod' of the context node</blockquote>
<tt>@*</tt>
<blockquote>is <i>all of</i> the attributes of the context node</blockquote>
<tt>timecard[@payperiod="12"]</tt>
<blockquote>is all 'timecard' children of the context node that have a
payperiod attribute with value '12'</blockquote>

<h3>
<a NAME="XSLT_commands"></a>Some of the most useful XSLT commands</h3>
To be written.
<br>&nbsp;
<br>&nbsp;
<h3>
<a NAME="files"></a>What to name your files and where to put them</h3>
To be written. $$$ Note to Mike: Need a section on what to name the stylesheet(s),
where to put on server, and how to relate that to the code.</td>
</tr>

<tr>
<td></td>

<td></td>
</tr>
</table>

</body>
</html>
