# $Author$
# $Date$
# $Id$
# $Name$
# $Revision$
#
# This file is used to control how the portal manages sessions.
# Related to this are things like memory mangement techniques and
# caching of Channels.
#
# Written by Zed A. Shaw <zed.shaw@ubc.ca> for the uPortal project v. 1.5.




# PROPERTY FORMAT DESCRIPTION: All properties are formatted in a
# specific way to avoid name clashes with other properties files.  The
# idea is that you could load this properties file into another
# Properties object and still be able to find the ones related to
# session management.  To do this, all session related properties
# begin with "session." (without quotes).  
#
# All of the options for session management are broken down into a
# series of sections, with each section simply being separated by
# periods.  So, the stuff related to how user logins are controlled
# all being with session.login.  All the stuff related to memory
# mangement begin with session.memory.
#
# Finally, options will consist of different things like letters,
# numbers, etc. as needed.  Just read the comment to find out what the
# format is for that option.  All switch type options (i.e. they can
# be either on or off, yes or no, true or false, etc.)  take ONLY
# "yes" or "no" (without qouotes).
#







# This option determines whether users are allowed to login from more
# than one browser.  User's previous sessions will be destroyed if you
# set this to "no".  Setting it to "yes" means that old sessions are
# killed off only when they time out, thus causing a kind of memory
# leak of sessions.  This should be set to "no" unless you need to do
# some testing with a single login account.  Otherwise, you'll have
# orphaned sessions as users login to your system without logging out.
# Setting this to "yes" also sets you up for a DOS where someone
# repeatedly logs into their account until you run out of memory.

session.login.allow_multiple=no






# Determines if guest users (i.e., people who haven't logged in yet)
# all get one LayoutBean object (stored in the SessionContext) which
# they all share, or if they get their own instance of LayoutBean in
# their sessions.  Setting this to "yes" forces all users to share a
# single LayoutBean, reducing their memory overhead substantially and
# reducing their processing load (making things run faster for
# guests).  
#
# Setting this to "no" is asking for trouble, since each guest user
# will get their own copy of the LayoutBean.  The problem with this is
# that there is no way to get rid of guest sessions, since they don't
# ever log out (they aren't logged in yet).  What will happen is that
# ANY person on the internet with a program like curl, wget, or siege
# can take down your site in about 10 minutes from a phone line.  ONLY
# SET THIS TO "no" IF YOU REALLY, REALLY, NEED TO GIVE EACH GUEST USER
# THEIR OWN SESSION.  If you need to do this, then you aren't using
# the portal correctly most likely, and should re-evaluate your
# configuration.

session.login.single_guest_layout=yes


# This option is really a session.login and session.memory option
# combined.  What it does is force the uPortal to deny people access
# to the system if the memory drops below a certain percentage used.
# Setting this to "yes" keeps people from logging in when memory is
# low.  Setting it to "no" will let people log in until everything
# comes crashing around your ears like a house made of toothpicks.

session.login.starvation_denies_login=yes



# When memory available drops below this amount in MB, the portal will
# start denying people entry to the system.  This is done two ways:
# The channel doing logins will quit letting people log in (giving
# them a nice error message), and the login process will fail with an
# error message.  
#
# NOTE: If you write a channel or different authentication system, you
# should look at the SessionManager.allowLogins() method, which is
# used to determine if logins are allowed or not.

session.login.starvation_limit=2





# Configures whether channels are cached or not.  Setting this to
# "yes" lets you use the "session.memory.cached_channels" option to
# list which channels should be cached for each user.  Setting it to
# "no" means that ALL channels will get cached, even if they don't
# need to be cached.  
#
# The idea behind this is that most channels don't need to be cached
# in the user's layout, they simply display some info and then quit.
# So, keeping them around only improves performance a little, but
# wastes memory a lot.  If your channel does not maintain any internal
# state, then it doesn't need to be cached.  If you set this to "yes",
# you can tell uPortal which channels need caching (read: which ones
# have internal state which must be maintained between browser
# requests).  The portal will then discard all the other channels and
# save quite a bit of memory.
#
# This will only hurt performance a little, unless some of your
# channels are real hogs and take a long time to start up.  If that's
# the case, cache only those channels.

session.memory.constrained_channel_caching=no







# This is a comma separated list of class names which should be
# cached.  The class names MUST be fully qualified or it will not
# work.  You'll see an error message in the portal.log indicating
# which ones couldn't be loaded.  
#
# NOTE: The interesting thing about the channels which must be cached
# is that they are also the channels which should not be on the guest
# user's layout (if using the session.login.single_guest_layout=yes
# option).  The reason being that these channels have an internal
# state which applies to (typically) one user at a time, not many
# users.  If you have a shared guest layout, then ALL of the guests
# will use the same cached channels, thus interfering with eachother.
#
# There are two things you must do to work around this (if you must
# put one of these channels on your main guest page): 1) Re-write the
# channel so that it stores it's state in the user's session object
# rather than as fields inside the object.  2) Re-write the channel so
# that it re-acquires any resources based on the data in the session.

session.memory.cached_channels=org.jasig.portal.channels.CIMAPMail,org.jasig.portal.xmlchannels.CBookmarks







# This turns on the feature where XML document describing the user's
# layout is stored in such a way that it will use less memory, but
# take a little longer to load.  Setting this to "yes" means that the
# user's layout document will be dropped when memory gets tight, and
# reloaded on demand for the user each time they need it.  Setting it
# to "no" will force their layout document to stay around, which will
# use up memory, but reduces the number of times the portal reads the
# layout from the database for the user.  
#
# Most of the time, the layout just sits in memory doing nothing
# really.  In average installations of uPortal, it was discovered that
# a lot of memory is wasted by keeping the layout documents in memory
# for each user.  Many times, these layout documents belong to users
# who are not active anymore.  Considering most layouts are 50K-200K
# in size, this is a significant load on the memory usage.  By letting
# the portal get rid of layout documents if it needs more memory, you
# can load quite a few more users.  We found that you can usually
# increase the user load by about 35% by setting this option to "yes".
#
# The warning for this option is that you may have "layout thrashing" if
# you start to run out of memory on a heavily loaded site.  Layout
# thrashing is where the portal is dropping layout documents when
# memory gets tight, but reloading them right after that.  If you see
# a major increase in the number of access to the PORTAL_USERS table
# in your database, then this is what's happening.  Try setting this
# to "no" and see if things improve.  
#
# Finally, this may allow quite a few users on, and it does let you
# get rid of stale layout documents, but it also makes memory usage
# unpredictable.  Because memory usage will expand and contract as
# needed, it will be harder for you to determine the amount of memory
# any number of users will take up.  If you need to be able to predict
# the amount of memory used up by the portal, you should set this to
# "no".  After you have predicted your load, and your confident that
# everything works right, you can set this to "yes" and get some
# improved performance and memory handling.

session.memory.layoutxml_dynamic_loading=yes


# This option tells the layout caching system where you want the layouts
# cached on the file system.  The layout mechanism does an additional level
# of caching in an attempt to prevent layout thrashing.  It first gets the
# layout from the database, then stores in in a local file cache, and
# finally keeps it in memory using a soft reference.  When the layout is
# requested again, it tries to get the layout in the reverse order:
# Memory, disk, then database.  This ensures that the layout is
# retrieved from a progressively faster location.
#
# It is safe to delete all the files in this cache directory if it
# gets too large.  Any layouts deleted will simply be reloaded later.
# It's a good idea to maybe do this in a cron job with a script.
# 
# Setting this option to a bogus directory is how you turn off this feature.
# It is the FULL PATH, not the relative path from the current directory.
#

session.memory.layoutxml_cache_directory=/change/me/to/point/at/your/base/cache





